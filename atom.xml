<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙套的博客</title>
  
  
  <link href="http://nerd-is.in/atom.xml" rel="self"/>
  
  <link href="http://nerd-is.in/"/>
  <updated>2021-05-14T10:28:18.053Z</updated>
  <id>http://nerd-is.in/</id>
  
  <author>
    <name>Loong_T ZHENG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>来了解一下 Jetpack Compose 吧</title>
    <link href="http://nerd-is.in/2019/11/06/%E6%9D%A5%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%20Jetpack%20Compose%20%E5%90%A7/"/>
    <id>http://nerd-is.in/2019/11/06/%E6%9D%A5%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%20Jetpack%20Compose%20%E5%90%A7/</id>
    <published>2019-11-06T16:00:00.000Z</published>
    <updated>2021-05-14T10:28:18.053Z</updated>
    
    <content type="html"><![CDATA[<p>发表时间：2019.11.7</p><p>在前不久的 Android Dev Summit ‘19 上，Jetpack Compose 终于发布了一个可直接获得的预览版。现在的版本还是 0.1.0-dev02，处于非常早期的版本，官方也再三强调非常有可能产生变化且无法用于生产环境。不过我认为这是简单了解一下 Compose 的好时机。有备而无患。</p><span id="more"></span><p>首先来了解一下现在尝试 Compose 所需要的环境：</p><ol><li>Android Studio 4.0 Canary1</li><li>Kotlin 1.3.60-eap-25</li><li>minSdkVersion 21（也就是 Android 5.0）</li></ol><p>好的，这篇文章就到此为止吧。</p><p><img src="https://tva1.sinaimg.cn/large/007X8olVly1g8f4evrq81j3023023jr6.jpg" alt="告辞"></p><p>等等！写都写了，我还是再多写一点吧。</p><p>演这么一出其实也是为了说明，Compose 真的还处于很早期的阶段，估计还需要很长一段路才能真正在项目中实际使用上。但早鸟多少能尝到些甜头。希望各位能通过简单的了解，预判一下以后的开发趋势，趁早规划，适时投资。</p><p>同时由于 Compose 还处于很可能发生很多变化的状态，所以本文也不准备过多拘泥于使用的细节，而是从更为大局的层面上介绍一下 Compose。当然，笔者本人经验和眼界极为有限，真知灼见是没有的，希望起到抛砖引玉的作用。</p><h2 id="开始体验"><a href="#开始体验" class="headerlink" title="开始体验"></a>开始体验</h2><p>请记得下载一个<a target="_blank" rel="noopener" href="https://developer.android.com/studio/preview">最新的 Android Studio</a>，需要 4.0 版本，在发文时这意味着你需要使用 canary channel 版本的。</p><p>开始新建一个项目，会发现多了一个 Empty Compose Activity 的选项，选择它，各种依赖会为你配置好。那么一个 hello world 会是这个样子的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            MyApp()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Text(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，你已经知道了 Compose 的基础知识，现在可以尝试用它来构建各种界面了。</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8f80fbncej301o01amx4.jpg" alt="打脸"></p><p>请先慢着动手。如果去看官网的入门教程，你所得到的核心内容的确就是这样。由于文档及教程还很不完善，这里我建议，出门左转学习一下 Flutter。</p><p>这不是一句玩笑话。Compose 在控件的使用以及组合上，跟 Flutter 更为相近，而跟 Android 之前的那套 UI 没有太大的关系。使用 Layout Inspector 这个工具来查看 Compose 编写的应用，可以看到 Activity 内是一个 AndroidComposeView 包含了很多 RepaintBoundaryView。而没有使用原先就有的 TextView 等控件。</p><p>假如你只接触过 Android 的 UI 编程，可能需要一段时间来熟悉然后转变原先的思维。虽然 Compose 本身还很不完善，但这种声明式的编程范式（declarative programming）可以通过学习 React 或者 Flutter 等 UI 框架未雨绸缪一番。</p><p>关于声明式编程稍后再提，我还是继续谈一下一些常见的情形。</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>在布局上，首先会教会你使用 Column 和 Row，能够对应代替 LinearLayout；FrameLayout 也换成了 Stack。如果你对  main axis、cross axis 还比较陌生，如上所说，可以尝试学习一下 React 和 Flutter。</p><p>视频中提到，Compose 对 ConstraintLayout 的支持还正在进行中。所以可以猜测还在对于现有的布局控件，以后应该还是会添加支持的。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>大多数应用都逃不了网络请求 + 列表展示！</p><p>Compose 提供了 VerticalScroller 和 HorizontalScroller 来生成列表，在使用上与 RecyclerView 是完全不同的体验：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    VerticalScroller &#123;</span><br><span class="line">        Column &#123;</span><br><span class="line">            repeat(<span class="number">20</span>) &#123;</span><br><span class="line">                Row(mainAxisSize = LayoutSize.Expand) &#123;</span><br><span class="line">                    Container(height = <span class="number">48.</span>dp) &#123;</span><br><span class="line">                        Text(<span class="string">&quot;Item <span class="variable">$it</span>&quot;</span>, modifier = Spacing(left = <span class="number">16.</span>dp))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，Scroller 与 ScrollView 更接近，只提供了一个滚动的功能，并没提到有对 View 进行回收复用。</p><h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    MaterialTheme &#123;</span><br><span class="line">        Surface(color = Color.White) &#123;</span><br><span class="line">            Text(text = <span class="string">&quot;Hello <span class="variable">$name</span>!&quot;</span>, style = +themeTextStyle &#123; h5 &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码添加了 Material 的主题。</p><p>在我看来，这种方式比使用 XML 那套繁琐、不直观、缺乏文档的方法要好太多。当然，也可能只是因为我菜。</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8gdget2b3j305d04wq2u.jpg" alt="我太菜"></p><h3 id="Live-Preview"><a href="#Live-Preview" class="headerlink" title="Live Preview"></a>Live Preview</h3><p>Android Studio 4.0 还提供了一个名为 Live Preview 的功能来预览 Compose 的效果。通过给 Compose 函数添加 <code>@Preview</code> 注解来预览该函数的效果。这个函数必须是无参的，而且可以给注解传递不同的参数来预览各种不同情况下（不同主题不同屏幕大小等）的界面。</p><p>功能是好功能，但代码发生变动后，必须要重新 build 后才能更新预览，现在效率还比较低。</p><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>最后谈谈当状态（数据）发生变化后，Compose 如何响应。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Model</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> state = State()</span><br><span class="line">    MaterialTheme &#123;</span><br><span class="line">        Stack &#123;</span><br><span class="line">            aligned(Alignment.Center) &#123;</span><br><span class="line">                Button(<span class="string">&quot;<span class="subst">$&#123;state.count&#125;</span> clicks&quot;</span>, &#123;</span><br><span class="line">                    state.count++</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，放置了一个按钮，每按一次按钮上的计数就会 +1。代码里并没有对 State 进行监听，然后再对 UI 进行更新。而是在 State 类上添加了 <code>Model</code> 注解，Compose 自动进行 UI 的更新（官方称之为 recompose）。</p><p>你或许会想：哦，<code>setState()</code>。</p><h2 id="Compose"><a href="#Compose" class="headerlink" title="Compose?"></a>Compose?</h2><h3 id="为什么需要-Compose"><a href="#为什么需要-Compose" class="headerlink" title="为什么需要 Compose"></a>为什么需要 Compose</h3><p>Android 已经十年，设备的变化非常大，也涌现出很多心的开发技术和思想，但用来开发 UI 的工具却还依旧停留在十年前。不少控件已经过时而且背负了太多历史包袱，重新开始或许是更好的选择。</p><p>开发 UI 需要编写 XML 布局，通过代码加载，可能还需要通过 XML 来定义 style，为了编写一个界面要做的工作太多了。而且考虑到 Activity 和 Fragment，需要顾及的就更多了。如果要自定义一个 View，要做什么工作？我想“自定义 View”这几个字，都能吓退一批人吧。</p><p>并且大量 UI 工具与系统的版本绑定，新功能新修复无法及时让开发者和用户受益。Material design？Who cares？那是 5.0 以上才大部分支持的东西，更别提 shape theming 了。</p><p>原先的控件使用了一些只有官方能使用的黑魔法，也就是 hidden API。Compose 将完全在公开的 API 上进行构建，官方使用的广大的普通开发者也能够使用。</p><p>插点私货。我偶尔会看着隔壁 Flutter 流下羡慕的泪水。它提供了大量官方的控件，应对各种场景，而且在各种系统版本上提供统一的行为。而我却需要满世界找非官方的实现，一个个查看是否满足我的需求，是否还在维护，是否需要自己魔改。当然，我无比感恩这些开发者的贡献，但我觉得我们应该被 Android 官方善待。</p><p>然后是 data flow。对于 UI 编程来说，分发事件和接收状态是与开发者关联最密切的事情。而现有的 android.widget 在这两个方面都做得不够好：状态的管理比较混乱；事件在分发时就已经改变了控件的状态；listener 可以跟 Kotlin 结合更紧密提供更合适的做法。</p><h3 id="声明式-UI-编程"><a href="#声明式-UI-编程" class="headerlink" title="声明式 UI 编程"></a>声明式 UI 编程</h3><p>声明式编程通常是相对于命令式编程（imperative programming）来说的，不关注编程中具体的过程，而是以最后的结果为重点。在 UI 这一特定的领域来说，声明式编程则意味着：当状态发生变化时，声明式框架会自动更新视图。</p><p>声明式的 UI 框架会关注：</p><ol><li>对于给定的数据，UI 是如何被展示的；</li><li>怎么对事件进行响应；</li><li>不考虑 UI 之前的状态对当前的状态产生的影响。</li></ol><p>也就是说，它只关心当前的数据（状态）会渲染出什么样的外观，而不把数据当成一个拥有上下文的状态流来看待。</p><h3 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h3><blockquote><p>Composition over inheritance.</p><p>组合优于继承。</p></blockquote><p>Compose 通过组合的方式构成界面。这或许也是起名叫 Compose 的原因。</p><p>遵循单一责任原则，Compose 函数都只有一个单一的目的，想实现某一种效果，就使用对应的 Compose 函数。比如想要设置背景，则需要使用 <code>Surface</code>，没有其他 Compose 函数可以做到这一点。</p><h2 id="Composable"><a href="#Composable" class="headerlink" title="@Composable"></a>@Composable</h2><p>使用 <code>@Composable</code> 注解的函数只能在另一个的 Composable 函数中调用。看到这句话，你可能会想起：“ 只有替身才能打倒替身 ！”</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8ohcynfdxj30f00dm7lb.jpg" alt="你在向我靠近吗"></p><p>如果你对 Kotlin Coroutine 有所了解，suspend 函数也同样只能在 suspend 函数中进行调用。而 coroutine 的实现，是 Kotlin 编译器在编译时，将 suspend 函数进行了改造，会给函数添加一个 Continuation 参数，并对函数体进行一定程度的改造。详细的这里不多写了。</p><p>对于 Composable 函数，同样也是使用了 Kotlin 编译器插件将函数变形了。Composable 函数里添加的则是 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/kotlin/androidx/compose/Composer">Composer</a>，这是一个类似于 gap buffer 的数据结构。Gap buffer 在文本编辑器里被普遍使用，有兴趣的可以多了解一下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再次强调，Compose 处于很早期的阶段，API 也好，具体的底层实现也好，都很可能会发生变化。官方的示例 JetNews 也存在一定的性能问题。</p><p>所以我觉得普通开发者还不需要去了解具体使用的细节。但还是有几个建议：</p><ul><li>如果还没学习 Kotlin，快学吧。</li><li>然后考虑学习一下 Kotlin coroutine。</li><li>学习已经比较成熟的声明式 UI 框架，比如 React 和 Flutter。考虑了解一下它们的应用和原理，比如状态管理的最佳实践和 virtual DOM 等。这样可以快速掌握同类型的 UI 框架。</li></ul><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><p><a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose">官网 Compose 页面</a></p><p><a target="_blank" rel="noopener" href="https://codelabs.developers.google.com/codelabs/jetpack-compose-basics">Codelab - Jetpack Compose Basics</a></p><p><a target="_blank" rel="noopener" href="https://github.com/android/compose-samples/tree/master/JetNews">官方示例 JetNews</a></p><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=VsStyq4Lzxo">Declarative UI Patterns (Google I/O’19)</a></p><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=dtm2h-_sNDQ">What’s New in Jetpack Compose (Android Dev Summit ‘19)</a></p><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Q9MtlmmN4Q0">Understanding Compose (Android Dev Summit ‘19)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;发表时间：2019.11.7&lt;/p&gt;
&lt;p&gt;在前不久的 Android Dev Summit ‘19 上，Jetpack Compose 终于发布了一个可直接获得的预览版。现在的版本还是 0.1.0-dev02，处于非常早期的版本，官方也再三强调非常有可能产生变化且无法用于生产环境。不过我认为这是简单了解一下 Compose 的好时机。有备而无患。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://nerd-is.in/tags/Android/"/>
    
    <category term="Jetpack" scheme="http://nerd-is.in/tags/Jetpack/"/>
    
    <category term="Compose" scheme="http://nerd-is.in/tags/Compose/"/>
    
  </entry>
  
  <entry>
    <title>一篇关于 Android 获取运营商的全面笔记</title>
    <link href="http://nerd-is.in/2019/10/19/%E4%B8%80%E7%AF%87%E5%85%B3%E4%BA%8E%20Android%20%E8%8E%B7%E5%8F%96%E8%BF%90%E8%90%A5%E5%95%86%E7%9A%84%E5%85%A8%E9%9D%A2%E7%AC%94%E8%AE%B0/"/>
    <id>http://nerd-is.in/2019/10/19/%E4%B8%80%E7%AF%87%E5%85%B3%E4%BA%8E%20Android%20%E8%8E%B7%E5%8F%96%E8%BF%90%E8%90%A5%E5%95%86%E7%9A%84%E5%85%A8%E9%9D%A2%E7%AC%94%E8%AE%B0/</id>
    <published>2019-10-19T16:00:00.000Z</published>
    <updated>2021-05-14T10:28:18.049Z</updated>
    
    <content type="html"><![CDATA[<p>发表时间：2019-10-20</p><h2 id="内容总览"><a href="#内容总览" class="headerlink" title="内容总览"></a>内容总览</h2><p>本文会给出在 Android 上获取运营商的方法，几个相近方法结果的差异，以及在多卡情况下有效的获取方式。最后额外提一下一种不需要请求设备识别码获取运营商信息的方法。提供可运行的 demo 源码。</p><span id="more"></span><h2 id="MCC-和-MNC"><a href="#MCC-和-MNC" class="headerlink" title="MCC 和 MNC"></a>MCC 和 MNC</h2><p>首先介绍一下这两个码，也是获取运营商所必须的。</p><p>MCC，Mobile Country Code，移动设备国家代码。MNC，Mobile Network Code，移动设备网络代码。MCC 和 MNC 串在一起后，可以用来表示唯一的移动设备运营商。我国的 MCC 是 460，MNC 则会出现一个运营商拥有多个的情况，比如联通有 01、06、09。当前的码表可以在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mobile_Network_Codes_in_ITU_region_4xx_(Asia)#China_-_CN">这个维基页面</a>找到。</p><p>于是可以先根据码表来构建这么一个类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkOperator</span></span>(<span class="keyword">val</span> opName: String) &#123;</span><br><span class="line"></span><br><span class="line">    Mobile(<span class="string">&quot;移动&quot;</span>),</span><br><span class="line">    Unicom(<span class="string">&quot;联通&quot;</span>),</span><br><span class="line">    Telecom(<span class="string">&quot;电信&quot;</span>),</span><br><span class="line">    Tietong(<span class="string">&quot;铁通&quot;</span>),</span><br><span class="line">    Other(<span class="string">&quot;其他&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据 [code]（MCC+MNC) 返回运营商</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">from</span><span class="params">(code: <span class="type">Int</span>)</span></span> = <span class="keyword">when</span> (code) &#123;</span><br><span class="line">            <span class="number">46000</span>, <span class="number">46002</span>, <span class="number">46004</span>, <span class="number">46007</span>, <span class="number">46008</span> -&gt; Mobile</span><br><span class="line">            <span class="number">46001</span>, <span class="number">46006</span>, <span class="number">46009</span> -&gt; Unicom</span><br><span class="line">            <span class="number">46003</span>, <span class="number">46005</span>, <span class="number">46011</span> -&gt; Telecom</span><br><span class="line">            <span class="number">46020</span> -&gt; Tietong</span><br><span class="line">            <span class="keyword">else</span> -&gt; Other</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fromOpName</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> (name) &#123;</span><br><span class="line">            <span class="string">&quot;移动&quot;</span> -&gt; Mobile</span><br><span class="line">            <span class="string">&quot;联通&quot;</span> -&gt; Unicom</span><br><span class="line">            <span class="string">&quot;电信&quot;</span> -&gt; Telecom</span><br><span class="line">            <span class="string">&quot;铁通&quot;</span> -&gt; Tietong</span><br><span class="line">            <span class="keyword">else</span> -&gt; Other</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你很可能也知道存在一个叫做 IMSI 的识别码（注意并不是 IMEI 哦）。国际移动用户识别码（International Mobile Subscriber Identity）可以在蜂窝网络中区分不同用户，它是由 MCC、MNC 和 MSIN（移动订户识别码，Mobile Subscription Identification Number）组成的。即 IMSI = MCC + MNC + MSIN。</p><h2 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h2><p>在 Android 上首先需要请求 <code>READ_PHONE_STATE</code> 权限，然后通过 TelephonyManager 相关方法来获取信息。TelephonyManager 有若干相近的方法，也让人挺困惑的。Demo 里会列出各个方法的结果，有兴趣的可以自行尝试一下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tm = getSystemService&lt;TelephonyManager&gt;()</span><br><span class="line"><span class="keyword">val</span> text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    TelephonyManager.getSimOperator(): <span class="subst">$&#123;tm.simOperator&#125;</span></span></span><br><span class="line"><span class="string">    TelephonyManager.getSimOperatorName(): <span class="subst">$&#123;tm.simOperatorName&#125;</span></span></span><br><span class="line"><span class="string">    TelephonyManager.getNetworkOperator(): <span class="subst">$&#123;tm.networkOperator&#125;</span></span></span><br><span class="line"><span class="string">    TelephonyManager.getNetworkOperatorName(): <span class="subst">$&#123;tm.networkOperatorName&#125;</span></span></span><br><span class="line"><span class="string">    TelephonyManager.getSubscriberId(): <span class="subst">$&#123;tm.subscriberId&#125;</span></span></span><br><span class="line"><span class="string">    Operator name: <span class="subst">$&#123;NetworkOperator.from(Integer.valueOf(tm.simOperator)).opName&#125;</span></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.trimIndent()</span><br></pre></td></tr></table></figure><p>在我的设备上得到的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TelephonyManager.getSimOperator(): 46009// 当前流量卡，联通</span><br><span class="line">TelephonyManager.getSimOperatorName(): CMCC// 联通</span><br><span class="line">TelephonyManager.getNetworkOperator(): 46000// 移动，卡一</span><br><span class="line">TelephonyManager.getNetworkOperatorName(): CHINA MOBILE  // 移动</span><br><span class="line">TelephonyManager.getSubscriberId(): 46002326951xxxx     // 移动，这就是 IMSI，xxxx 部分是由我隐去的</span><br><span class="line">Operator name: 联通</span><br></pre></td></tr></table></figure><p>那么得到了 MCC+MNC，就可以判断出运营商了。</p><h3 id="双卡情况"><a href="#双卡情况" class="headerlink" title="双卡情况"></a>双卡情况</h3><p>如果设备有双卡，该怎么样呢？切换流量卡后再来看一下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TelephonyManager.getSimOperator(): 46002// 当前流量卡，移动</span><br><span class="line">TelephonyManager.getSimOperatorName(): CMCC// 联通，跟 getSimOperator() 结果不符</span><br><span class="line">TelephonyManager.getNetworkOperator(): 46000// 移动</span><br><span class="line">TelephonyManager.getNetworkOperatorName(): CHINA MOBILE  // 移动</span><br><span class="line">TelephonyManager.getSubscriberId(): 46002326951xxxx // 移动</span><br><span class="line">Operator name: 移动</span><br></pre></td></tr></table></figure><p>通过尝试可以发现，<code>TelephonyManager.getSimOperator()</code> 方法获得的结果是根据当前设置的流量卡变化的。而其他的方法结果都没有变化，甚至得到的信息也是不统一的，可以说没什么用处。</p><p>不过我还无法确定这些方法的结果在不同设备不同 ROM 上的效果，仅供参考。可以下载 demo 来查看在自己设备上的结果。</p><h2 id="不需要权限的方法"><a href="#不需要权限的方法" class="headerlink" title="不需要权限的方法"></a>不需要权限的方法</h2><p>我们都知道 Android 会根据设备设置的不同，去加载不同的资源文件夹。最典型的，会根据系统的语言去加载不同语言的字符串资源。而 Android 也可以根据 MCC 和 MNC 加载不同的资源。</p><p>于是我灵光一闪，给 <code>values</code> 文件夹加上 <code>-mcc460-mnc00</code> 后缀，然后在里面放上对应运营商的名字字符串，就可以绕开权限获取到运营商了。</p><p>不过等等，这么一来要给每个 MNC 都写一个文件夹，还挺麻烦的，还是用代码来获取吧：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mcc = resources.configuration.mcc</span><br><span class="line"><span class="keyword">val</span> mnc = resources.configuration.mnc</span><br><span class="line"><span class="keyword">val</span> <span class="keyword">operator</span> = NetworkOperator.from(mcc * <span class="number">100</span> + mnc)</span><br></pre></td></tr></table></figure><p>这个方法也是有缺点的，不然我就把这个方法写在前了——无法获取到当前流量卡的信息，获取到的信息是固定的。</p><h2 id="Demo-源代码"><a href="#Demo-源代码" class="headerlink" title="Demo 源代码"></a>Demo 源代码</h2><p>运行以下命令来获得 demo 的源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b sim-operator https://github.com/Loong-T/demo.git</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;发表时间：2019-10-20&lt;/p&gt;
&lt;h2 id=&quot;内容总览&quot;&gt;&lt;a href=&quot;#内容总览&quot; class=&quot;headerlink&quot; title=&quot;内容总览&quot;&gt;&lt;/a&gt;内容总览&lt;/h2&gt;&lt;p&gt;本文会给出在 Android 上获取运营商的方法，几个相近方法结果的差异，以及在多卡情况下有效的获取方式。最后额外提一下一种不需要请求设备识别码获取运营商信息的方法。提供可运行的 demo 源码。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://nerd-is.in/tags/Android/"/>
    
    <category term="运营商" scheme="http://nerd-is.in/tags/%E8%BF%90%E8%90%A5%E5%95%86/"/>
    
  </entry>
  
  <entry>
    <title>实用的 Flutter 国际化指南</title>
    <link href="http://nerd-is.in/2019/03/01/%E5%AE%9E%E7%94%A8%E7%9A%84%20Flutter%20%E5%9B%BD%E9%99%85%E5%8C%96%E6%8C%87%E5%8D%97/"/>
    <id>http://nerd-is.in/2019/03/01/%E5%AE%9E%E7%94%A8%E7%9A%84%20Flutter%20%E5%9B%BD%E9%99%85%E5%8C%96%E6%8C%87%E5%8D%97/</id>
    <published>2019-03-01T16:00:00.000Z</published>
    <updated>2019-04-16T09:11:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个 Android 开发者，Flutter 上来就让我把各类字符串写在 widget 里，其实我心里是拒绝的。硬编码是不可能硬编码的。国际化又不会，就是只能去看看文档，才能学点新姿势这样子。看了文档之后，觉得国际化这部分，还是有点麻烦的，我觉得有必要拎出来单独写写。</p><span id="more"></span><p>个人希望能把应用的字符串资源独立出来，以方便管理。至于支持多语言这种，反而是顺带完成的结果。本文以实用优先，因为我认为这部分内容是每个应用都需要使用的。</p><h2 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h2><p>首先简单认识一下 Flutter 国际化相关的知识点。</p><p>添加 <code>flutter_localizations</code> 依赖，让 Flutter 知道我们需要使用国际化相关的包。Flutter 自带的 widget 中，也用到了一些字符串资源，比如，<code>showSearch()</code> 方法打开的搜索栏提示。而这个包可以提供英文之外的，被 Flutter 内部默认使用的国际化字符串资源。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">flutter:</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line"><span class="attr">flutter_localizations:</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">flutter</span></span><br></pre></td></tr></table></figure><p>然后在创建 App 时，加入 <code>LocalizationsDelegate</code>，国际化的内容就由这些类来提供。<code>GlobalMaterialLocalizations.delegate</code> 提供了 Material 组件库所使用的字符串资源；<code>GlobalWidgetsLocalizations.delegate</code> 则定义了在当前的语言中，文字默认的排列方向。</p><p>之后我们定义了自己的国际化内容后，也需要加入到这个列表的头部。</p><p>还要声明要支持什么语言，<code>supportedLocales</code> 这里添加了英文和中文两种。如果说用户的语言不在这个列表内，则会默认使用列表第一项指定的语言。假如你对这个规则不满意，可以使用 <code>localeResolutionCallback</code> 参数来自定义自己想要的规则。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_localizations/flutter_localizations.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      localizationsDelegates: [</span><br><span class="line">        GlobalMaterialLocalizations.delegate,</span><br><span class="line">        GlobalWidgetsLocalizations.delegate,</span><br><span class="line">      ],</span><br><span class="line">      supportedLocales: [</span><br><span class="line">        <span class="keyword">const</span> Locale(<span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;US&#x27;</span>),</span><br><span class="line">        <span class="keyword">const</span> Locale(<span class="string">&#x27;zh&#x27;</span>, <span class="string">&#x27;CN&#x27;</span>),</span><br><span class="line">      ],</span><br><span class="line">      title: <span class="string">&#x27;App Title&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: HomePage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们将一些自带的国际化资源加入到了应用中，Flutter 自身已经能够使用它们了。但我们要怎么使用它们呢？</p><p>通过 <code>MaterialLocalizations.of(context)</code> 获取到 <code>MaterialLocalizations</code> 的实例，然后访问里面的字符串。比如上面的 title 一行，可以替换为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onGenerateTitle: (context) =&gt; MaterialLocalizations.of(context).closeButtonLabel,</span><br></pre></td></tr></table></figure><p>注意这里将 title 替换成 onGenerateTitle 了，因为此时还在初始化 App 中，无法获取到 context，更无法通过 context 获取字符串了。</p><h2 id="自定义的国际化内容"><a href="#自定义的国际化内容" class="headerlink" title="自定义的国际化内容"></a>自定义的国际化内容</h2><p>现在来考虑怎么将我们自己的国际化加入到其中。也就是，需要在 <code>localizationsDelegates</code> 中加入自己的 <code>LocalizationsDelegate</code>。</p><p>查看文档，<code>LocalizationsDelegate</code> 需要一个泛型参数。参考官方的文档，可知这里指定的类型就是我们存放字符串的类。在这里，有两种选择：第一是基于 map 的，非常简单的实现；第二个则是通过 Dart 语言中专门负责国际化的 intl 包来实现。接下来我们按次来看看。</p><h3 id="基于-Map"><a href="#基于-Map" class="headerlink" title="基于 Map"></a>基于 Map</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleLocalizations</span> </span>&#123;</span><br><span class="line">  SimpleLocalizations(<span class="keyword">this</span>.locale);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Locale locale;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> SimpleLocalizations of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Localizations.of&lt;SimpleLocalizations&gt;(context, SimpleLocalizations);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&gt; _localizedValues = &#123;</span><br><span class="line">    <span class="string">&#x27;en&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;app_name&#x27;</span>: <span class="string">&#x27;App Name&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;hello_world&#x27;</span>: <span class="string">&#x27;Hello World&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;zh&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;app_name&#x27;</span>: <span class="string">&#x27;应用名&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;hello_world&#x27;</span>: <span class="string">&#x27;你好世界&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="keyword">get</span> _stringMap &#123;</span><br><span class="line">    <span class="keyword">return</span> _localizedValues[locale.languageCode];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> helloWorld &#123;</span><br><span class="line">    <span class="keyword">return</span> _stringMap[<span class="string">&#x27;hello_world&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> appName &#123;</span><br><span class="line">    <span class="keyword">return</span> _stringMap[<span class="string">&#x27;app_name&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，这种方法的原理非常简单，就是将所有字符串放进 map，然后通过应用的 <code>Locale</code> 来取出对应语言的字符串。使用时，就是 <code>SimpleLocalizations.of(context).helloWorld</code> 这样来引用字符串。</p><p>其对应的 <code>LocalizationsDelegate</code> 如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleLocalizationsDelegate</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">LocalizationsDelegate</span>&lt;<span class="title">SimpleLocalizations</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> SimpleLocalizationsDelegate();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> isSupported(Locale locale) =&gt; [<span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;zh&#x27;</span>].contains(locale.languageCode);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;SimpleLocalizations&gt; load(Locale locale) &#123;</span><br><span class="line">    <span class="keyword">return</span> SynchronousFuture&lt;SimpleLocalizations&gt;(SimpleLocalizations(locale));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldReload(SimpleLocalizationsDelegate old) =&gt; <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要将这个 <code>SimpleLocalizationsDelegate</code> 加入到上面的 delegates 列表中，国际化就算完成了。</p><p>回看一下整个流程，并不算复杂，需要经手部分的原理也非常简单，只是一个 map 的使用。使用这个方法可以将整个应用的字符串都集中到一起管理。但是，维护起来还是很不方便。</p><h3 id="基于-intl"><a href="#基于-intl" class="headerlink" title="基于 intl"></a>基于 intl</h3><p>接下来看看基于 intl 包的实现方法是怎么样的。</p><p>第一步，添加依赖：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">intl:</span> <span class="string">^0.15.7</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line">  <span class="attr">intl_translation:</span> <span class="string">^0.17.3</span></span><br></pre></td></tr></table></figure><p>通过查看官方的例子，可以知道 <code>Intl.message()</code> 方法是我们管理字符串的关键。于是去看相关的文档，会发现——嗯，没有卵用（甚至没解释每个参数有什么作用）。</p><p>接下来还是一样添加一个跟 <code>SimpleLocalizations</code> 差不多类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntlLocalizations</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> IntlLocalizations of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Localizations.of&lt;IntlLocalizations&gt;(context, IntlLocalizations);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> appName &#123;</span><br><span class="line">    <span class="keyword">return</span> Intl.message(<span class="string">&#x27;App Name&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> helloWorld &#123;</span><br><span class="line">    <span class="keyword">return</span> Intl.message(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从命令行中运行 <code>flutter pub pub run intl_translation:extract_to_arb --output-dir=你想要的输出目录 IntlLocalizations所在文件</code>。这一操作将会在指定目录里生成一个名为 intl_messages.arb 的文件，内容大致如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@@last_modified&quot;</span>: <span class="string">&quot;2019-02-17T15:57:00.554988&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;App Name&quot;</span>: <span class="string">&quot;App Name&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@App Name&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;placeholders&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Hello world&quot;</span>: <span class="string">&quot;Hello world&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@Hello world&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;placeholders&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这个文件复制一份，命名为 intl_en.arb，作为英文版本使用。接着再复制一份，命名为 intl_zh.arb 作为中文版本使用。将 intl_zh.arb 的内容修改为对应中文的内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@@last_modified&quot;</span>: <span class="string">&quot;2019-02-17T15:57:00.554988&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;App Name&quot;</span>: <span class="string">&quot;应用名&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@App Name&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;placeholders&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Hello world&quot;</span>: <span class="string">&quot;你好世界&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@Hello world&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;placeholders&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要其他语言的版本，请自行添加并修改。</p><p>再来输入一段长长的命令行：<code>flutter pub pub run intl_translation:generate_from_arb --output-dir=输出目录 --no-use-deferred-loading IntlLocalizations所在文件 所有arb文件</code>。这样会生成几个 <code>messages_</code> 开头的 dart 文件。可以自行查看一下里面的内容，我现在的 Dart 水平还比较菜，就先不分析其中的原理了。</p><p>其中名为 messages_all.dart 的文件里，生成了 <code>initializeMessages(String localeName)</code> 这个方法，将会在下面的步骤中使用到。</p><p>在 <code>IntlLocalizations</code> 中添加如下的方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Future&lt;IntlLocalizations&gt; load(Locale locale) &#123;</span><br><span class="line">  <span class="keyword">final</span> name =</span><br><span class="line">    locale.countryCode.isEmpty ? locale.languageCode : locale.toString();</span><br><span class="line">  <span class="keyword">final</span> localeName = Intl.canonicalizedLocale(name);</span><br><span class="line">  <span class="keyword">return</span> initializeMessages(localeName).then((_) &#123;</span><br><span class="line">    Intl.defaultLocale = localeName;</span><br><span class="line">    <span class="keyword">return</span> IntlLocalizations();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IntlLocalizations</code> 就准备完毕了。然后，开始实现 delegate，内容很简单：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntlLocalizationsDelegate</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">LocalizationsDelegate</span>&lt;<span class="title">IntlLocalizations</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> IntlLocalizationsDelegate();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> isSupported(Locale locale) =&gt; [<span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;zh&#x27;</span>].contains(locale.languageCode);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;IntlLocalizations&gt; load(Locale locale) &#123;</span><br><span class="line">    <span class="keyword">return</span> IntlLocalizations.load(locale);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldReload(IntlLocalizationsDelegate old) =&gt; <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就是正常使用流程了，这里不赘诉。回想整个流程，真正国际化的内容在 arb 文件中，对于集中管理字符串来说，比使用 map 还是好一点。但是整个流程还是显得异常麻烦，尤其是两次长得过分的命令行，明显应该由工具来改进。我相信 Flutter/Dart 团队应该会在这一点上做出优化。</p><h2 id="flutter-i18n"><a href="#flutter-i18n" class="headerlink" title="flutter_i18n"></a>flutter_i18n</h2><p>那么，有没有一款工具可以解救我们呢？您好，有的。</p><p>Android Studio（IDEA）上有一款名为 <a target="_blank" rel="noopener" href="https://github.com/long1eu/flutter_i18n">flutter_i18n</a> 的插件，可以帮助简化这个过程。其原理是通过 arb 文件来自动生成所需要的代码。</p><p>插件的使用非常简单，安装后会出现一个新的按钮。一旦你按下这个按钮——boom——插件就会根据 <code>res/values</code> 文件夹（Android 开发者觉得很亲切）中的 arb 文件，在 <code>lib/generated</code> 中生成 Dart 代码。</p><p>那么我们的重心就放在了 arb 文件上。Arb 文件全称是 Application Resource Bundle，是基于 JSON 的 balabala 接下去的我也不想接着说了，因为并不实用。还是来看下 Flutter 国际化中切实相关的部分。</p><p>虽然我们知道了 arb 文件是类 JSON 格式，但我们还并不清楚文件里具体需要什么样的内容。这里我们通过 <code>Intl.message()</code> 方法再重新认识一下。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> <span class="keyword">get</span> appName &#123;</span><br><span class="line">  <span class="keyword">return</span> Intl.message(</span><br><span class="line">    <span class="string">&#x27;App Name&#x27;</span>,</span><br><span class="line">    desc: <span class="string">&#x27;Name for the application&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;IntlLocalizations_appName&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> hello(<span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="keyword">return</span> Intl.message(</span><br><span class="line">    <span class="string">&#x27;Hello <span class="subst">$name</span>&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;IntlLocalizations_hello&#x27;</span>,</span><br><span class="line">    desc: <span class="string">&#x27;Say hello to someone&#x27;</span>,</span><br><span class="line">    args: [name],</span><br><span class="line">    locale: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">    examples: <span class="keyword">const</span> &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Someone&#x27;</span>&#125;,</span><br><span class="line">    meaning: <span class="string">&#x27;What is this?&#x27;</span>,</span><br><span class="line">    skip: <span class="keyword">false</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个更为详细的实现，其中 <code>hello</code> 方法将全部的参数都赋值了，以方便观察通过 <code>intl_translation</code> 包处理后的 arb 文件会是什么样的。</p><p>不过这之前简单介绍一下 <code>Intl.message()</code> 的部分参数。</p><ul><li><code>name</code> 参数必须与函数名一致，或者是<code>类名_方法名</code>这个形式——建议使用后者避免冲突；</li><li><code>args</code> 就是重复一遍参数；</li><li>如果方法没有参数，那么 <code>name</code> 和 <code>args</code> 可以省略；</li><li><code>desc</code> 参数就是描述这个字符串的字符串，必须是一个字符串字面量；</li><li><code>examples</code> 是参数的示例；</li><li><code>desc</code> 和 <code>examples</code> 在运行时不会被使用，但会被提取出来作为额外的信息提供给翻译人员作为参考；</li><li><code>skip</code> 如果为 true，那么这条记录就不会被提取出来；</li><li>其他的文档里并没有提。</li></ul><p>然后我们再运行一下那个很长的命令行，将其处理成 arb 文件看看：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@@last_modified&quot;</span>: <span class="string">&quot;2019-02-18T21:31:28.750455&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;IntlLocalizations_appName&quot;</span>: <span class="string">&quot;App Name&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@IntlLocalizations_appName&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Name for the application&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;placeholders&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;IntlLocalizations_hello&quot;</span>: <span class="string">&quot;Hello &#123;name&#125;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@IntlLocalizations_hello&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Say hello to someone&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;placeholders&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;example&quot;</span>: <span class="string">&quot;Someone&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，<code>meaning</code> 似乎没有用处。其核心就是 <code>&quot;IntlLocalizations_appName&quot;: &quot;App Name&quot;</code> 这样的一条一条的记录。以 @ 开头的部分，并不会真正在程序中使用，而是给翻译人员作为参考使用的。</p><p>这么一来，我们接下来就可以在 <code>res/values</code> 文件夹中创建需要的 arb 文件了。这个插件还提供了快捷创建 arb 文件的功能，只需要在 <code>res/values</code> 目录右键选择 New -&gt; Arb File 就可以选择这个 arb 文件的 locale 了。</p><p>需要注意的是，在这个插件中，如果字符串内需要包含变量，使用的语法是 <code>$var_name</code>，而不是上面例子里使用大括号的形式。</p><p>这里我创建了两个 arb 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strings_en.arb</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;appName&quot;</span>: <span class="string">&quot;App Name&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hello&quot;</span>: <span class="string">&quot;Hello $name&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// strings_zh_CN.arb</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;appName&quot;</span>: <span class="string">&quot;应用名&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hello&quot;</span>: <span class="string">&quot;你好$&#123;name&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用插件生成代码后，将 delegate 加入到应用的列表中，使用时也只要直接利用 <code>S</code> 这个类名来引用就好：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">    localizationsDelegates: [</span><br><span class="line">        S.delegate,</span><br><span class="line">        GlobalMaterialLocalizations.delegate,</span><br><span class="line">        GlobalWidgetsLocalizations.delegate,</span><br><span class="line">    ],</span><br><span class="line">    supportedLocales: [</span><br><span class="line">        <span class="keyword">const</span> Locale(<span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;US&#x27;</span>),</span><br><span class="line">        <span class="keyword">const</span> Locale(<span class="string">&#x27;zh&#x27;</span>, <span class="string">&#x27;CN&#x27;</span>),</span><br><span class="line">    ],</span><br><span class="line">    onGenerateTitle: (context) =&gt; S.of(context).appName,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>使用了这个插件之后，国际化就算得上方便了。生成的代码也可以稍微看一眼，或许有你用得到的其他方法。</p><p>最后提醒一句，由于生成代码是由插件完成的，所以依赖中的 <code>intl_translation</code> 可以删掉了。</p><h2 id="其他与总结"><a href="#其他与总结" class="headerlink" title="其他与总结"></a>其他与总结</h2><p>可能有的人会问，不使用 IDEA 的开发者，有没有什么更好的选择呢？或许有。现在还有一个名为 <a target="_blank" rel="noopener" href="https://pub.dartlang.org/packages/rosetta">rosetta</a> 的库，致力于解决 Flutter 国际化太过复杂的问题。我尝试过，但并没有跑通正常的流程，无法更多评价。有兴趣的朋友可以试试看。</p><p>到此，这篇指南就结束了，希望能对一些人有帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一个 Android 开发者，Flutter 上来就让我把各类字符串写在 widget 里，其实我心里是拒绝的。硬编码是不可能硬编码的。国际化又不会，就是只能去看看文档，才能学点新姿势这样子。看了文档之后，觉得国际化这部分，还是有点麻烦的，我觉得有必要拎出来单独写写。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Flutter" scheme="http://nerd-is.in/tags/Flutter/"/>
    
    <category term="International" scheme="http://nerd-is.in/tags/International/"/>
    
  </entry>
  
  <entry>
    <title>通过 FileProvider 共享文件</title>
    <link href="http://nerd-is.in/2018/05/26/%E9%80%9A%E8%BF%87%20FileProvider%20%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/"/>
    <id>http://nerd-is.in/2018/05/26/%E9%80%9A%E8%BF%87%20FileProvider%20%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/</id>
    <published>2018-05-26T14:17:00.000Z</published>
    <updated>2021-05-14T10:28:18.053Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到一个异常，<code>android.os.FileUriExposedException: file://*** exposed beyond app through Intent.getData()</code>，了解了一下，原来是 Android 7.0（api level 24）开始，通过 URI 与其他应用共享文件要求 URI 必须是 <code>content://</code> 开头的形式。而 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/support/v4/content/FileProvider">FileProvider</a> 是用来做这件事最简便的方法。</p><span id="more"></span><h1 id="声明-FileProvider"><a href="#声明-FileProvider" class="headerlink" title="声明 FileProvider"></a>声明 FileProvider</h1><p><code>FileProvider</code> 是 <code>ContentProvider</code> 的子类，所以需要在 <code>AndroidManifest.xml</code> 中进行声明。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;android.support.v4.content.FileProvider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">&quot;com.example.myapp.fileprovider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">&quot;@xml/filepaths&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将 <code>android:grantUriPermissions</code> 设为 <code>true</code> 会允许得到访问这个 <code>FileProvider</code> 下所有数据的权限。</p><p><code>meta-data</code> 这部分将会在后面再细说，其他部分都是常规 <code>ContentProvider</code> 的内容。</p><h1 id="指定可访问的文件"><a href="#指定可访问的文件" class="headerlink" title="指定可访问的文件"></a>指定可访问的文件</h1><p>在上面的部分中，<code>meta-data</code> 里指定了一个 xml 的资源文件，这个文件便是用来指定可以被访问到的文件的。</p><p>在资源文件夹中创建一个 xml 资源文件，根元素如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>paths</code> 内可以添加如下的元素：</p><ul><li><code>&lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：代表应用内部存储的 <code>files/</code> 目录，也就是 <code>Context.getFilesDir()</code> 方法所得到的目录。</li><li><code>&lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Context.getCacheDir()</code> 方法得到的目录。</li><li><code>&lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：外部存储目录，与 <code>Environment.getExternalStorageDirectory()</code> 方法得到的结果一样。</li><li><code>&lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：对应 <code>Context.getExternalFilesDir(null)</code> 方法。</li><li><code>&lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>: 对应 <code>Context.getExternalCacheDir()</code> 方法。</li><li><code>&lt;external-media-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>: 对应 <code>Context.getExternalMediaDirs()</code> 方法。</li></ul><p>以上元素都有 <code>name</code> 和 <code>path</code> 两个属性。</p><p>我从 <code>path</code> 属性说起。<code>path</code> 即是真实的子目录地址段。比如 <code>&lt;files-path  path=&quot;docs/&quot; /&gt;</code> 对应的是 <code>files/docs/</code> 目录。那么，如果不想要子目录，而是当前目录呢？用 <code>.</code> 啊！</p><p>而 <code>name</code> 属性则是提供给外部应用的一个虚假的子目录地址段（在 content URI 中使用），主要是为了安全考虑。</p><h1 id="为-File-生成-Content-URI"><a href="#为-File-生成-Content-URI" class="headerlink" title="为 File 生成 Content URI"></a>为 File 生成 Content URI</h1><p>使用 <code>FileProvider.getUriForFile()</code> 方法就可以为在指定目录里的文件生成 content URI。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File imagePath = <span class="keyword">new</span> File(Context.getFilesDir(), <span class="string">&quot;images&quot;</span>);</span><br><span class="line">File newFile = <span class="keyword">new</span> File(imagePath, <span class="string">&quot;default_image.jpg&quot;</span>);</span><br><span class="line">Uri contentUri = FileProvider.getUriForFile(getContext(), <span class="string">&quot;com.mydomain.fileprovider&quot;</span>, newFile);</span><br></pre></td></tr></table></figure><p>上面这段代码，再加上如下的资源文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">&quot;my_images&quot;</span> <span class="attr">path</span>=<span class="string">&quot;images/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后得到的 content URI 会是：<code>content://com.mydomain.fileprovider/my_images/default_image.jpg</code>。</p><p>再回头来看一下。com.mydomain.fileprovider 是 ContentProvider 指定的 authority，同时也是 <code>getUriForFile()</code> 方法所需的参数。my_images 是 <code>files-path</code> 元素的 <code>name</code> 属性，将会映射到真实目录 images/，也就是 <code>path</code> 属性。</p><p>🙂这里，Android 又有了些小残念，在编写代码的时候无法保证资源文件的字符串和代码中的字符串是一致的。只能等到运行时才能知道。</p><h1 id="为-URI-获取临时访问权限"><a href="#为-URI-获取临时访问权限" class="headerlink" title="为 URI 获取临时访问权限"></a>为 URI 获取临时访问权限</h1><p>通过上面的步骤，我们已得到一个地址正确的 URI，但这个 URI 还不能被其他应用正常使用。有两种方式来给予临时性的读写权限。</p><p>第一是使用 <code>Context.grantUriPermission()</code> 方法。这个方法需要指定要分享应用的包名。然后传入 <code>Intent.FLAG_GRANT_READ_URI_PERMISSION</code> 和 <code>Intent.FLAG_GRANT_WRITE_URI_PERMISSION</code> 来指定要授予的权限。给予权限之后，可以使用 <code>Context.revokeUriPermission()</code> 来取消；或者等到机器重启之后，这一次的授权也会失效。</p><p>这个方法需要事先设置应用的包名，并不是很实用。</p><p>第二个方法：可以使用 <code>Intent.setFlags()</code> 方法设置上面提到的两个 flag，来授予读写权限。此时，需要将这个 URI 用 <code>Intent.setData()</code> 来当成数据传递。由于我们多半是使用 Intent 来传递 URI 的，所以这个方法比较实用。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>出于安全考虑，7.0 引入了这个机制。一来可以避免暴露应用内部的文件系统信息，二来不要求文件数据接收方拥有 <code>READ_EXTERNAL_STORAGE</code> 权限。出发点是好的，在实现上略有瑕疵，总体感觉还不错，建议使用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近碰到一个异常，&lt;code&gt;android.os.FileUriExposedException: file://*** exposed beyond app through Intent.getData()&lt;/code&gt;，了解了一下，原来是 Android 7.0（api level 24）开始，通过 URI 与其他应用共享文件要求 URI 必须是 &lt;code&gt;content://&lt;/code&gt; 开头的形式。而 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://developer.android.com/reference/android/support/v4/content/FileProvider&quot;&gt;FileProvider&lt;/a&gt; 是用来做这件事最简便的方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://nerd-is.in/tags/Android/"/>
    
    <category term="FileProvider" scheme="http://nerd-is.in/tags/FileProvider/"/>
    
  </entry>
  
  <entry>
    <title>分享两个颜色资源文件</title>
    <link href="http://nerd-is.in/2017/07/17/%E5%88%86%E4%BA%AB%E4%B8%A4%E4%B8%AA%E9%A2%9C%E8%89%B2%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <id>http://nerd-is.in/2017/07/17/%E5%88%86%E4%BA%AB%E4%B8%A4%E4%B8%AA%E9%A2%9C%E8%89%B2%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</id>
    <published>2017-07-17T04:01:53.000Z</published>
    <updated>2021-05-14T10:28:18.053Z</updated>
    
    <content type="html"><![CDATA[<p>当初看到 Material Design 那个 48 秒的<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Q8TXgCzxEnw">视频</a>的时候，我心里就有声音在大喊：“就是这个！我想要的就是这种设计！”</p><p>迄今已有三年多，MD 得到了不错的推广。然而能让我眼前一亮的设计却是寥寥。大量的应用纯粹套了一个 MD 的皮，用着提供的标准控件，但没有更为深入地去设计，显得非常枯燥干瘪。这种时候 MD 反而成了累赘。</p><span id="more"></span><p>细看 Android 上的 MD，由于 Android 的系统版本限制，为了照顾 4.X 的用户，通常不会过多使用 5.0 才有的功能，比如转场动画、阴影。但想要做出好看的设计，动画与阴影不可少。视频展示的内容，可以说是没有一秒脱离这两个要素。</p><p>动画实现不易，且放一边。而阴影倒是容易不少，希望能多多加上。没有阴影的辅助，应用会看起来没有层次感。但又会看到不少滥用 card 的情况，也是心累。</p><p>而大部分使用了 Material Design 的应用看起来都大同小异的原因，大概就是颜色了。官方提供了一个 color palette，算是标准颜色库。颜色数量不少，但推荐拿来当主色调的，只有 500 系列。那是多少种呢？19 种（还有黑白两色没有算入）。事实上会拿来用的，不过那些看起来舒服的颜色：蓝、绿、灰等，可选的颜色可谓少之又少。在这之外还要再选取一种 accent color，还要与主色调形成一定的对比，当然，也不能太瞎眼。所以能用的颜色组合并不多，你能看到的，大概大部分都是绿色、蓝灰色、蓝色的吧。这样怎么会不枯燥呢？</p><p>我个人很喜欢 MD 的动效和阴影，还有跟图片的巧妙搭配。但对于官方推荐的颜色，我并不是很认同。如果是用在控件上的、少量装饰性的颜色，我会直接在官方的 color palette 中挑选。但如果要决定一个应用的主色调，我会尽量避免使用。</p><p>终于要提到本文的主题了，就是我想要分享的两个颜色资源。一个来自<a target="_blank" rel="noopener" href="http://nipponcolors.com/">日本の伝統色</a>，我将里面的颜色提取成 Android 的资源文件，并且放在了 Gist 上。你可以在<a target="_blank" rel="noopener" href="https://gist.github.com/Loong-T/ba3953685a2f3d32225468374ca3056f">这里</a>找到。网站本身也很好看，可以去观摩下。这些颜色我觉得对眼睛很友好，看起来都挺舒服。另一个来自<a target="_blank" rel="noopener" href="http://boxingp.github.io/traditional-chinese-colors/">中国传统颜色</a>，我自己没有用过很多，不知道效果如何，算是附赠吧。你可以在<a target="_blank" rel="noopener" href="https://gist.github.com/Loong-T/e204a3326bea1bccbdd4c581a1d1909f">这里</a>访问到。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当初看到 Material Design 那个 48 秒的&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.youtube.com/watch?v=Q8TXgCzxEnw&quot;&gt;视频&lt;/a&gt;的时候，我心里就有声音在大喊：“就是这个！我想要的就是这种设计！”&lt;/p&gt;
&lt;p&gt;迄今已有三年多，MD 得到了不错的推广。然而能让我眼前一亮的设计却是寥寥。大量的应用纯粹套了一个 MD 的皮，用着提供的标准控件，但没有更为深入地去设计，显得非常枯燥干瘪。这种时候 MD 反而成了累赘。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://nerd-is.in/tags/Android/"/>
    
    <category term="Resource" scheme="http://nerd-is.in/tags/Resource/"/>
    
    <category term="Color" scheme="http://nerd-is.in/tags/Color/"/>
    
    <category term="Design" scheme="http://nerd-is.in/tags/Design/"/>
    
    <category term="Material Design" scheme="http://nerd-is.in/tags/Material-Design/"/>
    
    <category term="分享" scheme="http://nerd-is.in/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="资源" scheme="http://nerd-is.in/tags/%E8%B5%84%E6%BA%90/"/>
    
    <category term="颜色" scheme="http://nerd-is.in/tags/%E9%A2%9C%E8%89%B2/"/>
    
    <category term="设计" scheme="http://nerd-is.in/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>dagger.android——Android 中使用 Dagger2 的新方法</title>
    <link href="http://nerd-is.in/2017/07/08/dagger-android%E2%80%94%E2%80%94Android-%E4%B8%AD%E4%BD%BF%E7%94%A8-Dagger2-%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://nerd-is.in/2017/07/08/dagger-android%E2%80%94%E2%80%94Android-%E4%B8%AD%E4%BD%BF%E7%94%A8-Dagger2-%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95/</id>
    <published>2017-07-08T16:00:00.000Z</published>
    <updated>2017-07-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>不打算讲解 Dagger2 的基础知识。</p><p>原先在 Android 项目中使用 Dagger2，准备好了 Component 和 Module 之后，在 Activity 或者 Fragment 里大概是这么使用的：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppComponent</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component(modules = &#123;</span></span><br><span class="line"><span class="meta">        AppModule.class,</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MainActivityComponent.<span class="function">Builder <span class="title">mainComponentBuilder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(ThisApplication application)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MainActivityComponent</span></span><br><span class="line"><span class="meta">@ActivityScope</span></span><br><span class="line"><span class="meta">@Subcomponent(modules = &#123;</span></span><br><span class="line"><span class="meta">        MainActivityModule.class,</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainActivityComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity mainActivity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subcomponent</span>.Builder</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="function">Builder <span class="title">mainModule</span><span class="params">(MainActivityModule mainModule)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">MainActivityComponent <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 MainActivity 中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupActivityComponent</span><span class="params">(AppComponent appComponent)</span> </span>&#123;</span><br><span class="line">    mainComponent = appComponent.mainComponentBuilder()</span><br><span class="line">            .mainModule(<span class="keyword">new</span> MainModule(<span class="keyword">this</span>))</span><br><span class="line">            .build();</span><br><span class="line">    mainComponent.inject(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码需要在生命周期方法中调用，之后才能正常使用被注入的对象。可以看到 MainActivity 需要知道自身是被 AppComponent 所注入，而被注入的类实际上不该了解（持有）注入者。<code>dagger.android</code> 就是为了在这一点上进行改进。</p><h2 id="先行知识"><a href="#先行知识" class="headerlink" title="先行知识"></a>先行知识</h2><p>在展示 <code>dagger.android</code> 之前，需要先了解一下 dagger 的 multibinding 功能，对于理解背后的运作机制有好处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultibindingModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@IntoMap</span></span><br><span class="line">    <span class="meta">@StringKey(&quot;a&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">provideAValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;a value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@IntoMap</span></span><br><span class="line">    <span class="meta">@StringKey(&quot;b&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">provideBValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;b value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，能够产生一个 <code>Map&lt;String, String&gt;</code>，包含了两个 entry，值分别是 <code>a value</code> 和 <code>b value</code>。这个 Map 可以当成构造参数传入某个地方，也可以像下面的代码一样直接在 Component 中使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(modules = MultibindingModule.class)</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MultibindingComponent</span> </span>&#123;</span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">aMap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里应该大致会明白 <code>@IntoMap</code> 的作用了。搭配 <code>@StringKey</code> 注解，<code>@IntoMap</code> 可以将方法的返回值加入一个 Map。假如需要的 key 的类型不是 <code>String</code>，也可以使用其他的注解，或者自定义一个注解。</p><p>有了 multibinding 功能之后，实际上已经可以将最初的注入方案进行改进了。具体可以参考这篇文章<a target="_blank" rel="noopener" href="https://medium.com/azimolabs/activities-subcomponents-multibinding-in-dagger-2-85d6053d6a95">Activities Subcomponents Multibinding in Dagger 2</a>。</p><p><code>dagger.android</code> 在原理上是接近的，算是一种标准化。</p><h2 id="使用-dagger-android"><a href="#使用-dagger-android" class="headerlink" title="使用 dagger.android"></a>使用 <code>dagger.android</code></h2><p>以撰文时的最新版本 <code>2.11</code> 为例说明。假定我们的应用组织层次是 <code>Appliction &lt;-- MainActivity &lt;-- MainFragment</code>，这样方便说明。</p><p>第一件事是添加依赖。<code>dagger.android</code> 需要在原来的基础上再添加依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.google.dagger:dagger-android:2.11&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.google.dagger:dagger-android-support:2.11&#x27;</span> <span class="comment">// 如果使用 support library</span></span><br><span class="line">annotationProcessor <span class="string">&#x27;com.google.dagger:dagger-android-processor:2.11&#x27;</span></span><br><span class="line"><span class="comment">// kapt &#x27;com.google.dagger:dagger-android-processor:2.11&#x27; // 使用 Kotlin kapt</span></span><br></pre></td></tr></table></figure><p>在 AppComponent 这一级，将 <code>AndroidInjectionModule</code> 加入 modules：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(modules = &#123;</span></span><br><span class="line"><span class="meta">        AndroidInjectionModule.class,</span></span><br><span class="line"><span class="meta">        AppModule.class,</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(ThisApplication application)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 MainActivity 这一层，首先确保使用的是 <code>@Subcomponent</code>，并且使 MainComponent 继承 <code>AndroidInjector&lt;T&gt;</code>。至于 <code>T</code> 的类型，这里需要被注入的是 MainActivity，所以就是 <code>MainActivity</code>。在 Subcomponent 内的 Builder，则需要继承 <code>AndroidInejector.Builder&lt;MainActivity&gt;</code>。由于 <code>AndroidInejector.Builder</code> 本身是抽象类，所以原本的 Builder 也需要改为抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subcomponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainActivityComponent</span> <span class="keyword">extends</span> <span class="title">AndroidInjector</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Subcomponent</span>.Builder</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">AndroidInjector</span>.<span class="title">Builder</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module(subcomponents = MainActivityComponent.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivityModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binds</span></span><br><span class="line">    <span class="meta">@IntoMap</span></span><br><span class="line">    <span class="meta">@ActivityKey(MainActivity.class)</span></span><br><span class="line">    <span class="keyword">abstract</span> AndroidInjector.Factory&lt;? extends Activity&gt;</span><br><span class="line">    bindActivityInjectorFactory(MainActivityComponent.Builder builder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中同时也新增了 MainActivityModule，Module 注解中将 subcomponents 指定为 MainActivityComponent。其他内容依葫芦画瓢。再将 MainActivityModule 添加到 AppComponent 中（感谢 <a target="_blank" rel="noopener" href="https://github.com/xiaobailong24">@xiaobailong24</a> 指出该处遗漏）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(modules = &#123;</span></span><br><span class="line"><span class="meta">        AndroidInjectionModule.class,</span></span><br><span class="line"><span class="meta">        AppModule.class,</span></span><br><span class="line"><span class="meta">        MainActivityModule.class,</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(ThisApplication application)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，依赖部分已经编写完毕，接下来是使用依赖。修改自定义的 Application：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">HasActivityInjector</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> DispatchingAndroidInjector&lt;Activity&gt; dispatchingActivityInjector;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    DaggerApplicationComponent.create().inject(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AndroidInjector&lt;Activity&gt; <span class="title">activityInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatchingActivityInjector;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Application 实现了 HasActivityInjector，方法的实现仅是返回一个 dagger 为我们注入的对象。</p><p>最后在 Activity 中，在 <code>onCreate</code> 方法前，调用一个方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    AndroidInjection.inject(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h2><p>最后实现注入的代码，无疑是 <code>AndroidInjection.inject(this)</code> 这一句，那么来看看这个方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    checkNotNull(activity, <span class="string">&quot;activity&quot;</span>);</span><br><span class="line">    Application application = activity.getApplication();</span><br><span class="line">    <span class="keyword">if</span> (!(application <span class="keyword">instanceof</span> HasActivityInjector)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                String.format(</span><br><span class="line">                        <span class="string">&quot;%s does not implement %s&quot;</span>,</span><br><span class="line">                        application.getClass().getCanonicalName(),</span><br><span class="line">                        HasActivityInjector.class.getCanonicalName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AndroidInjector&lt;Activity&gt; activityInjector =</span><br><span class="line">        ((HasActivityInjector) application).activityInjector();</span><br><span class="line">    checkNotNull(</span><br><span class="line">            activityInjector,</span><br><span class="line">            <span class="string">&quot;%s.activityInjector() returned null&quot;</span>,</span><br><span class="line">            application.getClass().getCanonicalName());</span><br><span class="line"></span><br><span class="line">    activityInjector.inject(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，就是从 Application 得到 ActivityInjector，调用 <code>inject</code> 方法注入这个 activity。Application 所持有的 <code>DispatchingAndroidInjector</code>，内部维护了一个 map。可以注意到，这个 map 的类型是 <code>Map&lt;Class&lt;? extends T&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends T&gt;&gt;&gt;</code>，并且构造方法使用了 <code>@Inject</code> 注解来注入这个 map。可知这个 map 便是我们使用 <code>@ActivityKey</code> 和 <code>@IntoMap</code> 所产生的。</p><p>AndroidInjector.Factory 的实现则是我们所写的 Subcomponent.Builder。通过 MainActivity.class 在 map 里得到对应的 AndroidInjector.Factory 后，就可以创建对应的 Component——也就是 AndroidInjector——接着就可以将 Component 所拥有的类型注入进 Activity 了。</p><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><p>观察上面例子里的 MainActivityComponent，会发现这个接口的实际内容只有指定了 MainActivity 的类型，其他的部分都是固定的。减少 boilerplate code 是 dagger 的目的之一，所以针对这种情况，dagger 添加了一个 <code>@ContributesAndroidInjector</code> 注解，用来生成这样的 Subcomponent。</p><p><code>@ContributesAndroidInjector</code> 使用在 module 中的抽象方法上。该方法不该有参数，返回类型必须是 Activity、Fragment 和 Service 等 Android Framework 的类型。dagger 将会为这样的一个方法生成一个对应的 Subcomponent。这个注解还能接受一系列 Module 作为值，这些 module 将会成为所生成的 Subcomponent 的 module。</p><p>对应上面的例子，可以将 MainActivityComponent 文件删除，然后将 MainActivity 改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivityModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ContributesAndroidInjector</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> MainActivity <span class="title">contributeMainActivity</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 ProGuard 时，需要加入如下规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># dagger</span><br><span class="line">-dontwarn dagger.android.**</span><br></pre></td></tr></table></figure><p>如果你想看实际使用的例子，可以参考我的 <a target="_blank" rel="noopener" href="https://github.com/Loong-T/Android-Showcase">Android Showcase</a>。</p><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p><code>dagger</code> 的基础使用并不是很难。但在结合实际项目后，需要合理组织层级，考虑 Scope 的使用，配合上额外的 <code>Subcomponent</code> 等等，再加上 Android 独特的环境，往往会变得复杂而繁琐。而 <code>dagger.android</code> 很好地简化了 DI 的使用，能够将更多精力放到实际的应用上，个人推荐使用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不打算讲解 Dagger2 的基础知识。&lt;/p&gt;
&lt;p&gt;原先在 Android 项目中使用 Dagger2，准备好了 Component 和 Module 之后，在 Activity 或者 Fragment 里大概是这么使用的：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://nerd-is.in/tags/Android/"/>
    
    <category term="Dagger" scheme="http://nerd-is.in/tags/Dagger/"/>
    
    <category term="依赖注入" scheme="http://nerd-is.in/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
    <category term="DI" scheme="http://nerd-is.in/tags/DI/"/>
    
  </entry>
  
  <entry>
    <title>迁移博客到 GitHub Pages</title>
    <link href="http://nerd-is.in/2017/02/19/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0-GitHub-Pages/"/>
    <id>http://nerd-is.in/2017/02/19/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0-GitHub-Pages/</id>
    <published>2017-02-19T08:39:36.000Z</published>
    <updated>2021-05-14T10:28:18.053Z</updated>
    
    <content type="html"><![CDATA[<p>最近补了一下 Web 方面的知识，心想着就顺带把博客重新鼓捣一下。</p><p>以前的博客——很久没更新了——是租了个便宜的虚拟主机，用 WordPress 搭的。并不懂 PHP，而且一段时间里也应该不会去学。如果我自己想要搞点自己想要的主题，实际练习一下自己的 Web 技术，会比较困难。付费也挺麻烦的，干脆就把这一个月几块钱也省了算了。</p><span id="more"></span><p>于是 GitHub Pages 成了首选，简单方便。因为是静态网站，想要自己练个手也很容易。</p><p>静态网站生成方面，我选用了 Hexo。GitHub 官方推荐 Jekyll，但由于想尝个鲜，就选用了比较火的 Hexo。然后发现 Hexo 是基于 Node 的，不禁想感叹 JS 和 Node 真是如日中天。</p><p>然后找了个看着顺眼的主题 <a target="_blank" rel="noopener" href="https://material.viosey.com/">Material</a>。这个主题视觉设计上很棒，并不是常见的那些平庸丑陋的 Material Design。然而感觉在布局和功能的设计上还是不尽我意，争取更熟悉了之后自己造一个吧。好在主题提供了几种样式，其中的 Isolation 十分简洁美观，于是决定先使用这个。</p><p>稍微自定义了一下主题，现在正在写第一篇博文。接下来就是搞定部署和域名绑定。</p><p>再长远一点的计划，就是支持社会化评论系统和 Https 了。</p><p>原先的评论系统用的是多说。别的不说，默认很丑。由于也没打算把原先的数据转到这里来，加上不支持 Https，所以不打算再使用多说。Disqus 在国内被墙了，由于基本都是翻墙的，所以一直没注意到这点。好在了解到网易云跟帖是支持 Https 的，于是计划使用它。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近补了一下 Web 方面的知识，心想着就顺带把博客重新鼓捣一下。&lt;/p&gt;
&lt;p&gt;以前的博客——很久没更新了——是租了个便宜的虚拟主机，用 WordPress 搭的。并不懂 PHP，而且一段时间里也应该不会去学。如果我自己想要搞点自己想要的主题，实际练习一下自己的 Web 技术，会比较困难。付费也挺麻烦的，干脆就把这一个月几块钱也省了算了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blog" scheme="http://nerd-is.in/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>读《离水之鱼》</title>
    <link href="http://nerd-is.in/2015/05/10/%E8%AF%BB%E3%80%8A%E7%A6%BB%E6%B0%B4%E4%B9%8B%E9%B1%BC%E3%80%8B/"/>
    <id>http://nerd-is.in/2015/05/10/%E8%AF%BB%E3%80%8A%E7%A6%BB%E6%B0%B4%E4%B9%8B%E9%B1%BC%E3%80%8B/</id>
    <published>2015-05-10T16:00:00.000Z</published>
    <updated>2017-02-23T10:41:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><a target="_blank" rel="noopener" href="http://book.douban.com/subject/10773372/">《离水之鱼》</a></p><p>个人评价：2 星。</p><p>并没有读完，过程中就感到有很多问题，想着这真是本鸡汤的反面示范。有了些想法后，就觉得是能够用来写点什么的。于是准备写个读后感，在准备阶段发觉，细看这本书更是糟糕。</p><p>尽量写一些个人对于鸡汤类型文字的想法。虽然每次深入去思考这些糟糕的鸡汤也会有所收获——主要是指为什么糟糕这方面，但相当耗费时间，并不值得这样的投入。所以最好这篇读后感能成为糟糕鸡汤文的最后一篇感想。</p><span id="more"></span><hr><p>首先来看看全书的结构。</p><p>目录的主体是以 Step 加数字开头的章节名称，然后前后加上前言、语录、致谢。没有更多的东西了。主要内容分为 7 章，说不上多，在没有二级结构的情况下，组成了一本 250 页略少的书，让我觉得有些微妙。</p><p>我列一下：</p><blockquote><p>前言<br>Step 1 找到真实的自我<br>Step 2 把独特之处当做诱饵<br>Step 3 找到同类<br>Step 4 用自己的方式，在别人的海洋里畅游<br>Step 5 把自己推到台前<br>Step 6 广撒网，常进步<br>Step 7 运用你的独特力量，吊到丰盈收获<br>离水之鱼精彩语录<br>致谢</p></blockquote><p>这个 Step 1~7，就是作者总结出的“离水鱼儿七步法”，用来帮助离水之鱼发现自己的独特潜力。从这一点上来看，结构紧扣主题，中规中矩。</p><p>而后在读的时候，会发现文中有二级标题格式的内容，但却怎么看都不像是二级标题。</p><p>因为懒，我就列个第一章的内容：</p><blockquote><p>Step 1 找到真实的自我<br>    了解自我是一辈子的事儿<br>    生活在恐惧当中，等于根本没有活过<br>    真实意味着言行一致，意味着真诚，毫不矫饰<br>    表达情绪，一定要选对时机<br>    这一生中，我们可以拥有不同的身份，拥有多种职业<br>    谈谈令你自豪的东西，不要博取同情，不要可以地“触动心弦”<br>    勇敢地展示自我，破除他人的成见<br>    为自己心怀歉意，别人会认为你是可怜虫<br>    当你跟别人都不一样的时候，你已经吸引了旁人的注意<br>    要知道自己适合什么、擅长什么<br>    即使在最阴暗的日子里，也会有光明<br>    如果你是一条离水鱼儿，感恩的心态不能少<br>    职场中的重要美德</p></blockquote><p>我誊抄这些小标题的时候，就快被气炸了：什么狗屁玩意儿！</p><p>首先可以肯定的是，翻译定然算不上高水准，也就是过了个通顺的坎儿。“即使在最阴暗的日子里，也会有光明”，这样的句子，以我这么没文化的人来，也该是翻成“黑暗中终能见光明”之类的。</p><p>先不论小标题想要表达的意思是否真的管用，来看小标题是不是真有表达出意思来吧。</p><p>最后一条，“职场中的重要美德”，这种表述方式，难道不是白写吗？至少请告诉我到底是什么美德吧？</p><p>“或许是太长了不好放在小标题内。”我这么猜测。</p><p>于是去看标题下的内容，第一句赫然便是：“重要提示：如果你不够真实，同事们一眼就能看穿。”</p><p>于是你把这句话直接放到小标题有什么不妥吗？！哦，是怕别人发现这其实跟前面的“真实意味着言行一致，意味着真诚，毫不矫饰”讲述的同一回事儿吗？</p><p>真是哔了狗了…</p><p>总结起来，上面提到了两个问题：不知所云、重复。</p><p>另外的问题有：无关、罗嗦。我也懒于细致挑刺。</p><hr><p>从内容的组织结构来看，我颇为怀疑作者是否真的了解如何解决问题。</p><p>当碰见一个问题后，正统的思维应当是去思考 what、how、why。</p><ul><li>What：问题是什么，问题中涉及的东西是什么。</li><li>How：解决的手段、途径。</li><li>Why：为什么这样是有效的，根据是什么。</li></ul><p>以上是我个人经验的粗浅总结，假若有所不妥，请不吝指教。</p><p>Step 1 的内容，实际上是“如何找到真实的自我”。</p><p>将上述思维套用在该问题上：</p><ul><li>What：什么是真实的自我？</li><li>Why：为什么要找到真实的自我？</li><li>How：怎么找到真实的自我？</li></ul><p>这样一来，行文的结构就清晰明了，也有理有据令人信服。</p><hr><p>但作者还是深知引人注意的要诀的：讲故事。全书穿插着大量的故事，自己的，别人的，总而言之就是各种成功人士的。</p><p>大概是出于加强说服力与代入感的考虑，大部分的故事都是使用第一人称来叙述的。但限于贫瘠的讲故事能力——或许是翻译的错——故事毫无吸引力，人物也毫无张力。只是单纯的例子而已，跟 1+1=2 并没有什么两样。而且故事的背景也与我个人的经历相距甚远，千篇一律。</p><p>我不是很待见鸡汤类型的书，因为大部分就是表达一个观点，然后举例子来支持自己的观点。但这些例子只能用来支持，无法证明该观点。</p><p>这些例子极有可能是经过挑选的。比如对于一个成功学的观点，作者挑了一个典型的例子，但却完全没有提到其他不支持该观点的例子。</p><p>很多鸡汤也太过暧昧不清了。以本书来说明，上面的提纲中提到“勇敢地展现自我”，却又说“表达情绪，一定要选对时机”。这不啻于说：“做事，要讲究‘度’。”</p><p>这观点本身并没有错，却是废话。大道理我想大部分人都明白，但这个“度”到底要如何平衡呢？这才是真正的问题啊。大部分鸡汤相当于在说：“买股票是可以赚大钱的，但前提是你要买对。”</p><p>啧，那到底怎么才能买对，你倒是告诉我啊。</p><hr><p>批判就完了。虽然读时心中想法千转，到著文时却像是完全没了头脑。而且写得也完全没有趣味。</p><p>我为什么要买这本书呢？</p><p>经不住购物优惠的诱惑，挑书的时候瞥见了书名——《离水之鱼 与众不同一族的生存法则》。还是不得不承认这个话题对于自觉离水之鱼的人，比如我，是非常有吸引力的。经过技术书籍的价格轰炸，对于这类书定价的想法，完全就是真便宜真便宜买买买。</p><p>不过事实证明这类书籍水分也充足得让我总是觉得“又是一笔亏本买卖”。</p><p>我买来看了一小部分后，发觉我与作者对于“离水之鱼”的理解是不一样的。</p><p>书中定义说：离水之鱼是指脱离了适合生存环境的鱼。适合别人生活的一般环境，对于这样的鱼来说，是无水环境。</p><p>而我自己的想法是，离水表示的并不是状态，而是向往。离水之鱼是那些渴望脱离水生存的人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;http://book.douban.com/subject/10773372/&quot;&gt;《离水之鱼》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;个人评价：2 星。&lt;/p&gt;
&lt;p&gt;并没有读完，过程中就感到有很多问题，想着这真是本鸡汤的反面示范。有了些想法后，就觉得是能够用来写点什么的。于是准备写个读后感，在准备阶段发觉，细看这本书更是糟糕。&lt;/p&gt;
&lt;p&gt;尽量写一些个人对于鸡汤类型文字的想法。虽然每次深入去思考这些糟糕的鸡汤也会有所收获——主要是指为什么糟糕这方面，但相当耗费时间，并不值得这样的投入。所以最好这篇读后感能成为糟糕鸡汤文的最后一篇感想。&lt;/p&gt;</summary>
    
    
    
    
    <category term="读书" scheme="http://nerd-is.in/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>在 SwipeRefreshLayout 中加入多个子 View</title>
    <link href="http://nerd-is.in/2014/09/28/%E5%9C%A8%20SwipeRefreshLayout%20%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%A4%9A%E4%B8%AA%E5%AD%90%20View/"/>
    <id>http://nerd-is.in/2014/09/28/%E5%9C%A8%20SwipeRefreshLayout%20%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%A4%9A%E4%B8%AA%E5%AD%90%20View/</id>
    <published>2014-09-28T16:00:00.000Z</published>
    <updated>2017-02-23T09:43:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017-02-23 更新：旧文搬运。</p><p>SwipeRefreshLayout 是由官方提供的下拉刷新 Widget。最低在 v4 中可用。最近使用了一下，发现虽然是官方出品，但也还是不够理想。</p><p>原先尝试使用了 Android L 中提供的新支持库 RecyclerView，彼此之间的兼容性就不够好。（RecyclerView 在那是也是新库，bug 多多，现在当然没有这种情况了。）</p><p>后来因为需要实现滑动到底部自动加载更多数据的功能，把 RecyclerView 换回了 ListView。在打算添加 <a target="_blank" rel="noopener" href="https://github.com/makovkastar/FloatingActionButton">FloatingActionButton</a> 在同一画面上时，发现 SwipeRefreshLayout 不够方便。根据 FloatingActionButton 这个库的说明，需要将 FloatingActionButton 与 ListView 放在同一 ViewGroup 下。</p><span id="more"></span><p>但是 SwipeRefreshLayout 只能有一个子视图，不然就会丢异常。于是自然就会在 SwipeRefreshLayout 下加一个 ViewGroup 包装一层来解决这个问题。这样一来，抛出异常的问题是解决了。但是运行后发现，ListView 只能上滑，而不能下拉。一旦下拉，就会触发 SwipeRefreshLayout 的下拉刷新。</p><p>可想而知，这是在事件派发上出了问题。下拉的事件在通常情况下应该由 ListView 来进行处理；当 ListView 滚动位置位于顶部时，再由 SwipeRefreshLayout 来进行处理。而现在的情况是，所有下拉手势全都由 SwipeRefreshLayout 处理的。</p><p>查阅关于事件派发的资料后，也没有想到比较可行的解决方案。接下来去查看了一下 SwipeRefreshLayout 的源码，结果不怎么麻烦的就解决了。</p><p>根据事件派发的知识，在 SwipeRefreshLayout 中找到相关的方法 <code>onInterceptTouchEvent(MotionEvent ev)</code> 和 <code>onTouchEvent(MotionEvent ev)</code>。查看它们的代码，发现在onIntercreptTouchEvent中有这么一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isEnabled() || mReturningToStart || canChildScrollUp()) &#123;</span><br><span class="line">    <span class="comment">// Fail fast if we&#x27;re not in a state where a swipe is possible</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，<code>canChildSrollUp()</code> 方法跟我的问题有密切关联。再追看 <code>canChildSrollUp()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Whether it is possible for the child view of this layout to</span></span><br><span class="line"><span class="comment"> *         scroll up. Override this if the child view is a custom view.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canChildScrollUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &lt; <span class="number">14</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTarget <span class="keyword">instanceof</span> AbsListView) &#123;</span><br><span class="line">            <span class="keyword">final</span> AbsListView absListView = (AbsListView) mTarget;</span><br><span class="line">            <span class="keyword">return</span> absListView.getChildCount() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (absListView.getFirstVisiblePosition() &gt; <span class="number">0</span> || absListView.getChildAt(<span class="number">0</span>)</span><br><span class="line">                            .getTop() &lt; absListView.getPaddingTop());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mTarget.getScrollY() &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ViewCompat.canScrollVertically(mTarget, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释中也说了，如果子视图是自定义的，那么重写这个方法即可。mTarget 就是 SwipeRefreshLayout 中默认的唯一的子视图。现在根据我的要求，继承 SwipeRefreshLayout 后，将这个方法改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canChildScrollUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &lt; <span class="number">14</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mScrollableChild <span class="keyword">instanceof</span> AbsListView) &#123;</span><br><span class="line">            <span class="keyword">final</span> AbsListView absListView = (AbsListView) mScrollableChild;</span><br><span class="line">            <span class="keyword">return</span> absListView.getChildCount() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (absListView.getFirstVisiblePosition() &gt; <span class="number">0</span> || absListView.getChildAt(<span class="number">0</span>)</span><br><span class="line">                    .getTop() &lt; absListView.getPaddingTop());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mScrollableChild.getScrollY() &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ViewCompat.canScrollVertically(mScrollableChild, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>mScrollableChild</code> 是由自己定义的，可以滚动的 View。</p><p>现在，下拉滚动的问题已经解决了。接下来就是要方便地指定这个 <code>mScrollableChild</code>。我希望在我自定义的 SwipeRefreshLayout 中，用 xml 的属性来指定一个id，然后将这个指定 id 的 View 加载到 <code>mScrollableChild</code> 上。</p><p>在 values 文件夹中新建一个 attrs.xml，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;ImprovedSwipeLayoutAttrs&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;scrollableChildId&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>于是就可以如下代码一样使用了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">in.nerd_is.inactive_weibo.ui.ImprovedSwipeLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:fab</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:isl</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/swipe_container&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@color/md_blue_grey_50&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">isl:scrollableChildId</span>=<span class="string">&quot;@+id/list_statuses&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;in.nerd_is.inactive_weibo.ui.StatusesFragment&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/list_statuses&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:minHeight</span>=<span class="string">&quot;?android:attr/listPreferredItemHeight&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingTop</span>=<span class="string">&quot;12dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingBottom</span>=<span class="string">&quot;12dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingLeft</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingRight</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:clipToPadding</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:divider</span>=<span class="string">&quot;@android:color/transparent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:dividerHeight</span>=<span class="string">&quot;12dp&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">com.melnykov.fab.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button_floating_action&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;bottom|right&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_md_create&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">fab:fab_colorNormal</span>=<span class="string">&quot;@color/md_blue_400&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">fab:fab_colorPressed</span>=<span class="string">&quot;@color/md_blue_grey_500&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">in.nerd_is.inactive_weibo.ui.ImprovedSwipeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ImprovedSwipeLayout 全部代码如下，很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImprovedSwipeLayout</span> <span class="keyword">extends</span> <span class="title">SwipeRefreshLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = ImprovedSwipeLayout.class.getCanonicalName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mScrollableChildId;</span><br><span class="line">    <span class="keyword">private</span> View mScrollableChild;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImprovedSwipeLayout</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImprovedSwipeLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line"></span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(</span><br><span class="line">                attrs, R.styleable.ImprovedSwipeLayoutAttrs);</span><br><span class="line">        mScrollableChildId = a.getResourceId(R.styleable.ImprovedSwipeLayoutAttrs_scrollableChildId, <span class="number">0</span>);</span><br><span class="line">        mScrollableChild = findViewById(mScrollableChildId);</span><br><span class="line">        a.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canChildScrollUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ensureScrollableChild();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &lt; <span class="number">14</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mScrollableChild <span class="keyword">instanceof</span> AbsListView) &#123;</span><br><span class="line">                <span class="keyword">final</span> AbsListView absListView = (AbsListView) mScrollableChild;</span><br><span class="line">                <span class="keyword">return</span> absListView.getChildCount() &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; (absListView.getFirstVisiblePosition() &gt; <span class="number">0</span> || absListView.getChildAt(<span class="number">0</span>)</span><br><span class="line">                        .getTop() &lt; absListView.getPaddingTop());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mScrollableChild.getScrollY() &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ViewCompat.canScrollVertically(mScrollableChild, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureScrollableChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mScrollableChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mScrollableChild = findViewById(mScrollableChildId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;2017-02-23 更新：旧文搬运。&lt;/p&gt;
&lt;p&gt;SwipeRefreshLayout 是由官方提供的下拉刷新 Widget。最低在 v4 中可用。最近使用了一下，发现虽然是官方出品，但也还是不够理想。&lt;/p&gt;
&lt;p&gt;原先尝试使用了 Android L 中提供的新支持库 RecyclerView，彼此之间的兼容性就不够好。（RecyclerView 在那是也是新库，bug 多多，现在当然没有这种情况了。）&lt;/p&gt;
&lt;p&gt;后来因为需要实现滑动到底部自动加载更多数据的功能，把 RecyclerView 换回了 ListView。在打算添加 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/makovkastar/FloatingActionButton&quot;&gt;FloatingActionButton&lt;/a&gt; 在同一画面上时，发现 SwipeRefreshLayout 不够方便。根据 FloatingActionButton 这个库的说明，需要将 FloatingActionButton 与 ListView 放在同一 ViewGroup 下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://nerd-is.in/tags/Android/"/>
    
    <category term="View" scheme="http://nerd-is.in/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Android 中的 Task 和  Back stack</title>
    <link href="http://nerd-is.in/2013/08/18/Android-%E4%B8%AD%E7%9A%84-Task-%E5%92%8C-Back-stack/"/>
    <id>http://nerd-is.in/2013/08/18/Android-%E4%B8%AD%E7%9A%84-Task-%E5%92%8C-Back-stack/</id>
    <published>2013-08-18T16:00:00.000Z</published>
    <updated>2017-02-20T08:16:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017-02-20 更新：旧文搬运。内容很浅显，但这部分内容实际上是需要好好掌握的，等以后会再充实一下。</p><p>在近来做的实战项目中，终于涉及到了这个方面的内容，那就趁机学一学用一用。</p><p>事实上，这方面的内容并不难理解，但是总让我感觉不知该怎么用才好。这里也就只能列一列几种模式，至于相应的解决方法，还是需要自己去琢磨试验。</p><span id="more"></span><p>下面的内容参考，都是来自官方文档。</p><p>Task 是用户在进行特定操作时调用的 activity 的一个集合。这些 activity 是由回退栈（back stack）来进行管理的，以打开的顺序来进行排列。</p><p>Home screen 是大多数 task 开始的地方。当用户在点击应用的图标时，该应用的 task 就来到了前台；如果还没有它的 task，则会新建一个。打开的 activity 则会被放在这个 stack 最底部（事实上也是在回退栈的最顶部，因为栈内只有这么一个元素）。</p><p>当在栈内的这个 activity 打开其他的 activity 时，新的 activity 会被被放置在栈的顶部，并且得到焦点。用户点击返回键后，当前的 activity 被销毁，同时也从栈中被弹出，此时在栈顶的 activity 被恢复。在回退栈中的 activity 是不可能进行重新排序的，只有栈的 push 和 pop 操作（LIFO）。</p><p>继续按返回键，task 中的 activity 将会依次被弹出，直到其中再没有 activity，这时，这个 task 也就不存在了。</p><p>用户开始一个新的 task 时，原来的 task 可以被移到后台，其中的所有 activity 都会停止，但回退栈保持完整。并且用户此时可以回到原来的 task，比如通过选择最近应用，或者是在主页再次点击开始那个应用。</p><p>需要注意的是，当运行了太多的 task 时，系统会开始销毁后台的 activity。被销毁的 activity 的状态将会丢失，但是 task 的回退栈不会丢失。</p><p>如果一个 activity 能在多个 activity 中被打开，由于回退栈不能被重新排序，此时这个回退栈中会出现这个 activity 的多个实例，甚至在多个 task 中被实例化多次。这时候再点击返回键，还是依旧将这些 activity 依次弹出，并且各自有各自的状态。如果不想 activity 被实例化多次，可以对这种行为进行更改。</p><h2 id="定义启动模式"><a href="#定义启动模式" class="headerlink" title="定义启动模式"></a>定义启动模式</h2><p>启动模式允许你定义新的 activity 实例与当前 task 的关系。有两种定义方法：</p><ol><li>使用 manifest 文件</li><li>使用 Intent 的 flags</li></ol><p><code>&lt;activity&gt;</code> 中可使用的属性：</p><ul><li>taskAffinity</li><li>launchMode</li><li>allowTaskReparenting</li><li>clearTaskOnLaunch</li><li>alwaysRetainTaskState</li><li>finishOnTaskLaunch</li></ul><p>flags 可使用的值：</p><ul><li>FLAG_ACTIVITY_NEW_TASK</li><li>FLAG_ACTIVITY_CLEAR_TOP</li><li>FLAG_ACTIVITY_SINGLE_TOP</li></ul><p>Intent 的 flags 方式优先于 manifest，但是，两个方式不能等同。某些效果只能通过在 manifest 中定义的启动模式实现，不能通过 flags 实现；反之亦然。</p><h3 id="使用-manifest-文件"><a href="#使用-manifest-文件" class="headerlink" title="使用 manifest 文件"></a>使用 manifest 文件</h3><p>使用 <code>&lt;activity&gt;</code> 元素中的 launchMode 属性。launchMode 属性可设为四种启动模式：</p><ul><li>standard<br>  默认值。系统在启动 activity 的 task 中创建一个新的 activity 实例，并且将 intent 传送给它。该 activity 可以被实例化多次，各个实例可以属于不同的 task，一个 task 中也可以存在多个实例。</li><li>singleTop<br>  如果 activity 已经存在一个实例并位于当前 task 的栈顶，则系统会调用已有实例的 <code>onNewIntent()</code> 方法把 intent 传递给已有实例，而不是创建一个新的实例。activity 可以被实例化多次，各个实例可以属于不同的 task，一个 task 中可以存在多个实例（但仅当栈顶的实例不是该 activity 的）。</li><li>singleTask<br>  系统将创建一个新的 task，并把 activity 实例作为根放入其中。但是，如果 activity 已经在其它 task 中存在实例，则系统会通过调用其实例的 <code>onNewIntent()</code> 方法把 intent 传给已有实例，而不是再创建一个新实例。 此 activity 同一时刻只能存在一个实例。</li><li>singleInstance<br>  除了系统不会把其它 activity 放入当前实例所在的 task 之外，其它均与 singleTask 相同。 无论 activity 是在一个新的 task 中启动，还是位于其它已有的 task 中，用户总是可以用回退键返回到前一个 activity 中。 但是，如果你启动了一个启动模式设为singleTask的 activity，且有一个后台 task 中已存在实例的话，则这个后台 task 就会整个转到前台。 这时，当前的回退栈就包含了这个转入前台的 task 中所有的 activity，位置是在栈顶。</li></ul><h3 id="使用Intent标志"><a href="#使用Intent标志" class="headerlink" title="使用Intent标志"></a>使用Intent标志</h3><p>这个标志可以修改的默认模式包括：</p><ul><li>FLAG_ACTIVITY_NEW_TASK<br>  在新的 task 中启动 activity。如果要启动的 activity 已经运行于某 task 中，则那个 task 将调入前台，最后保存的状态也将恢复，activity 将在 <code>onNewIntent()</code> 中接收到这个新 intent。 这个过程与前一节所述的  singleTask 模式相同。</li><li>FLAG_ACTIVITY_SINGLE_TOP<br>  如果要启动的 activity 就是当前 activity（位于回退栈顶），则已存在的实例将接收到一个 <code>onNewIntent()</code> 调用，而不是创建一个 activity 的新实例。 这个过程与前一节所述的 singleTop 模式相同。</li><li>FLAG_ACTIVITY_CLEAR_TOP<br>  如果要启动的 activity 已经在当前 task 中运行，则不再启动一个新的实例，且所有在其上面的 activity 将被销毁，然后通过 <code>onNewIntent()</code> 传入 intent 并恢复 activity（不在栈顶）的运行。 此种模式在launchMode中没有对应的属性值。FLAG_ACTIVITY_CLEAR_TOP 常与 FLAG_ACTIVITY_NEW_TASK 一起使用。这表示先定位其它 task 中已存在的 activity，再把它放入可以响应 intent 的位置。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;2017-02-20 更新：旧文搬运。内容很浅显，但这部分内容实际上是需要好好掌握的，等以后会再充实一下。&lt;/p&gt;
&lt;p&gt;在近来做的实战项目中，终于涉及到了这个方面的内容，那就趁机学一学用一用。&lt;/p&gt;
&lt;p&gt;事实上，这方面的内容并不难理解，但是总让我感觉不知该怎么用才好。这里也就只能列一列几种模式，至于相应的解决方法，还是需要自己去琢磨试验。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://nerd-is.in/tags/Android/"/>
    
    <category term="Task" scheme="http://nerd-is.in/tags/Task/"/>
    
  </entry>
  
  <entry>
    <title>使用 EasyBCD 引导 CentOS</title>
    <link href="http://nerd-is.in/2013/03/08/%E4%BD%BF%E7%94%A8-EasyBCD-%E5%BC%95%E5%AF%BC-CentOS/"/>
    <id>http://nerd-is.in/2013/03/08/%E4%BD%BF%E7%94%A8-EasyBCD-%E5%BC%95%E5%AF%BC-CentOS/</id>
    <published>2013-03-08T16:00:00.000Z</published>
    <updated>2017-02-20T07:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017-02-20 更新：旧文搬运、修缮。我记得 Win8 开始，使用了比较棘手的引导系统，不知现在这方法是否还有效。</p><p>昨晚重启后忽然进不了 Windows，各种搜索加各种尝试后依旧无果，不得已只能使用 PE 修复 MBR 的引导。</p><p>这个办法是我尽力避免的，因为修复后会把 GRUB 覆盖掉，那么我就无法进入 Linux 系统了。这之后修复 Linux 的引导又是一番额外功夫。以前也算是碰见过类似的问题，当时用了 EasyBCD 这个软件来引导系统，所以这一次也立马想到了这个软件。不过还是碰见了不少问题，一上午才真正解决了这个问题。经验难得，需要记录一下。</p><span id="more"></span><p>以前用 EasyBCD 的时候，纯粹是乱折腾，多加几个不同的引导，直白地碰运气，问题也解决了。但这一次没有这么好的人品。这次安装系统的时候把 /boot 单独挂载到一个分区上，猜测这就是以前的方法不奏效的原因。</p><p>经过这一次的折腾，对系统的引导算是多了一些理解。其中各种曲折，各种重启，写一下正确的解决办法。</p><p>参考文献有：<a target="_blank" rel="noopener" href="http://wenku.baidu.com/view/2367b2d926fff705cc170a48.html" title="百度文库资料">百度文库的一篇</a>（这个是重点），<a target="_blank" rel="noopener" href="http://neosmart.net/wiki/display/EBCD/NeoGrub" title="EasyBCD 官方文档">EasyBCD 官方文档</a>，<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/225343.htm" title="Grub 百科">GRUB 的百度百科</a>。</p><hr><p>安装好 EasyBCD 后，添加引导，选择 NeoGrub，安装，配置。这时候出现使用记事本打开的 menu.lst，这里要添加的就是关键了。</p><p>首先来看看官方给出的Ubuntu引导实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">titleUbuntu Gutsy Gibbon    </span><br><span class="line">root(hd1,2)    <span class="comment">#Load Ubuntu from the 2nd harddrive&#x27;s 3rd partition.</span></span><br><span class="line"><span class="comment">#Next Line: Translate (hd1,2) to Linux notation and set that as the root partition</span></span><br><span class="line">kernel/boot/vmlinuz-2.6.22-14-generic root=/dev/sdbc</span><br><span class="line">initrd/boot/initrd.img-2.6.22-14-generic</span><br></pre></td></tr></table></figure><p>title 是引导系统的名字，自己写一个能辨认的就好。</p><p>root 这一行是装载指定的分区，如果装载的分区不正确，那么下面指定的文件自然就不能被找到，引导自然失败。root 后有一个空格，括号内是第几个硬盘的第几个分区。hd0 是第一块硬盘，0 是这一块硬盘的第一个分区，依次类推。这里需要装载的是 /boot 所在的分区。</p><p>kernel 行指定 Linux 的内核，位置在 /boot 下，名字一般是以 vmlinuz 开头的一个文件。如果 /boot 是单独挂载，位置应该类似：<code>/vmlinuz-2.6.22-14-generic</code>。</p><p>如果不知道内核的名称，重启进入 NeoGrub，按 c 进入命令行模式，使用 root 命令装载分区后可以使用 TAB 键列出文件或命令。请注意这个功能，下面的 initrd 文件也需要使用相同的方法来获得。内核名字后的 <code>root=***</code> 必不可少，我在这里栽了很久。有一些 Linux 下硬盘相关知识的应该不难理解这一句。不是很清楚的请参考<a target="_blank" rel="noopener" href="http://vbird.dic.ksu.edu.tw/linux_basic/0130designlinux_2.php" title="鸟哥的 Linux 私房菜">鸟哥的相关内容</a>。<code>/dev/sd??</code> 这个其实指的就是根目录/所在的分区。</p><p>initrd 也是一个文件，与内核 vmlinuz 同在 /boot 下。名称可能是 initrd 开头的一个文件，但也可能是 initramfs 开头的一个 img 文件，在我的系统上就是如此。</p><p>在这之后可能还需要添加一句 boot 命令。</p><p>这里说明一下我的误区。因为我的 /boot 是单独挂载的，所以不能同时用 root 命令装载 <code>/</code> 和 <code>/boot</code>。让我对怎么指定 <code>root=</code> 后的根目录很伤脑筋。在我查看 GRUB 的百度百科的时候，学习到在加载了内核文件后，/boot 等就已经挂载到根目录下了。所以只需要使用<code>root=/dev/sd??</code> 这样的写法来指定就好了，而不必考虑自己在 GRUB 中装载的是哪一个分区。</p><p>下面是我成功引导的menu.lst文件，供参考：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NeoSmart NeoGrub Bootloader Configuration File</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is the NeoGrub configuration file, and should be located at C:\NST\menu.lst</span></span><br><span class="line"><span class="comment"># Please see the EasyBCD Documentation for information on how to create/modify entries:</span></span><br><span class="line"><span class="comment"># http://neosmart.net/wiki/display/EBCD/</span></span><br><span class="line"></span><br><span class="line">default 0</span><br><span class="line">timeout 8</span><br><span class="line"></span><br><span class="line">title CentOS 6.3</span><br><span class="line">    root (hd0,4)</span><br><span class="line">    kernel /vmlinuz-2.6.32-279.el6.x86_64 root=/dev/sda8</span><br><span class="line">    initrd /initramfs-2.6.32-279.el6.x86_64.img</span><br><span class="line">    boot</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;2017-02-20 更新：旧文搬运、修缮。我记得 Win8 开始，使用了比较棘手的引导系统，不知现在这方法是否还有效。&lt;/p&gt;
&lt;p&gt;昨晚重启后忽然进不了 Windows，各种搜索加各种尝试后依旧无果，不得已只能使用 PE 修复 MBR 的引导。&lt;/p&gt;
&lt;p&gt;这个办法是我尽力避免的，因为修复后会把 GRUB 覆盖掉，那么我就无法进入 Linux 系统了。这之后修复 Linux 的引导又是一番额外功夫。以前也算是碰见过类似的问题，当时用了 EasyBCD 这个软件来引导系统，所以这一次也立马想到了这个软件。不过还是碰见了不少问题，一上午才真正解决了这个问题。经验难得，需要记录一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://nerd-is.in/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 与 Ubuntu 下安装 NVIDIA 驱动</title>
    <link href="http://nerd-is.in/2013/03/06/CentOS-%E4%B8%8E-Ubuntu-%E4%B8%8B%E5%AE%89%E8%A3%85-NVIDIA-%E9%A9%B1%E5%8A%A8/"/>
    <id>http://nerd-is.in/2013/03/06/CentOS-%E4%B8%8E-Ubuntu-%E4%B8%8B%E5%AE%89%E8%A3%85-NVIDIA-%E9%A9%B1%E5%8A%A8/</id>
    <published>2013-03-06T16:00:00.000Z</published>
    <updated>2017-02-20T04:59:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017-02-20 更新：旧文搬运，略加修缮，觉得还实用，所以保留下来。<br>2013-08-29 更新：Ubuntu 下安装方法，详见最下。</p><p>NVIDIA 驱动安装的重点在于关闭系统本身默认运行的 nouveau 模块。</p><p>首先上参考文章吧。<a target="_blank" rel="noopener" href="http://enetq.blog.51cto.com/479739/591622">文章一</a>还有<a target="_blank" rel="noopener" href="http://www.ideasr.com/thread-33171-1-1.html">文章二</a>。两篇文章的方法略有不同，我综合了一下。</p><span id="more"></span><p>去 Nvidia 官网下载对应的显卡驱动，我下载的驱动文件名为：NVIDIA-Linux-x86_64-310.32.run。</p><p>这部分操作大量使用 root 权限，所以最好还是使用 root 身份来进行。</p><p>第一步需要关闭 X Windows，运行：<code>init 3</code>。</p><p>如果现在运行驱动安装程序 <code>sh NVIDIA-Linux-x86_64-310.32.run</code>，有可能会提示你：</p><blockquote><p>ERROR: The Nouveau kernel driver is currently in use by your system. This  driver is incompatible with the NVIDIA driver, and must be disabled  before proceeding.</p></blockquote><p>意思就是 nouveau 这个模块正在运行中，该模块与NVIDIA驱动不兼容，必须要被禁用才可以进行。为了禁用这个模块，大费周折，找了不少资料文章，总算试验出有效的方法。</p><p>过程中也看见一些传说，说是某些 Linux 发行版本禁用该模块也不算麻烦，但是 CentOS 似乎并不在那个阵营里。</p><p><strong>更新：添加 blacklist 或许没有什么影响，可以选择跳过这部分，直接到修改 <code>/etc/grub.conf</code> 文件部分。</strong></p><p>编辑 <code>/etc/modprobe.d/blacklist.conf</code>，在某处（但是不要选在注释里）加上 <code>blacklist nouveau</code>。</p><p>然后下面一步我估计可以选做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 备份 the initramfs file</span><br><span class="line">mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r).img.bak</span><br><span class="line">* 重新建立 the initramfs file</span><br><span class="line">dracut -v /boot/initramfs-$(uname -r).img $(uname -r)</span><br></pre></td></tr></table></figure><p>如果你运行了上面的两句命令，那请记好你曾经备份过 initramfs 这个文件。如果以后出错，可以还原试试。</p><p>在 CentOS 里似乎必须还需要下面这一步。因为我单独试了上面两步后并没有效果。</p><p>编辑 <code>/etc/grub.conf</code> 文件，禁止 nouveau KMS 的使用。</p><p>在这个文件里找到现在所在的系统项目，应该形如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title CentOS (2.6.32-279.el6.x86_64)</span><br><span class="line">        root (hd0,4)</span><br><span class="line">        kernel /vmlinuz-2.6.32-279.el6.x86_64 ro root=UUID=55151a0d-b460-462b-b5c6-97dfd4a3d328 rd_NO_LUKS  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_MD LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet</span><br><span class="line">        initrd /initramfs-2.6.32-279.el6.x86_64.img</span><br></pre></td></tr></table></figure><p>在 kernel 行的最后加上 <code>nouveau.modeset=0</code>。加上后的文件应该如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title CentOS (2.6.32-279.el6.x86_64)</span><br><span class="line">        root (hd0,4)</span><br><span class="line">        kernel /vmlinuz-2.6.32-279.el6.x86_64 ro root=UUID=55151a0d-b460-462b-b5c6-97dfd4a3d328 rd_NO_LUKS  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_MD LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet nouveau.modeset=0</span><br><span class="line">        initrd /initramfs-2.6.32-279.el6.x86_64.img</span><br></pre></td></tr></table></figure><p>保存退出后重新启动，再进入文本模式。使用下面的命令来查看一下 nouveau 是否有被加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep nouveau</span><br></pre></td></tr></table></figure><p>如果结果为空，那应该是成功了，可以接下去进行驱动的安装。驱动的安装倒是很简单，我就不打算写一遍了。详细的可以参考<a target="_blank" rel="noopener" href="http://www.ideasr.com/forum.php?mod=viewthread&tid=7738&extra=page=1&page=1">这一篇文章</a>。</p><hr><p>更新 Ubuntu 下安装方法：</p><p>在 Ubuntu 下安装驱动的方法步骤还是与在 CentOS 中差不多。</p><p>在引导中加入 <code>nouveau.modeset=0</code> 禁用 nouveau（加不加blacklist关系不大），然后在 CLI 环境下安装驱动。</p><p>Ubuntu 的引导文件位置与 CentOS 并不一样，具体在哪里我也忘了，请自行搜索解决吧。</p><p>禁用 nouveau 后，需要进入 CLI 环境，但是使用 <code>init 3</code> 命令并不能关闭 X Window，会导致安装无法继续进行。</p><p>解决办法是使用 Ctrl+Alt+F1 切换到文字界面下，然后将 dm 服务停止就可以关闭 X Window。Ubuntu 的默认 dm 是 lightdm，其他还有 kdm、gdm 等，请根据自己的情况来选择。</p><p>运行命令 <code>sudo service lightdm stop</code> 来停止X Window。接下来就可以按流程安装驱动了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2017-02-20 更新：旧文搬运，略加修缮，觉得还实用，所以保留下来。&lt;br&gt;2013-08-29 更新：Ubuntu 下安装方法，详见最下。&lt;/p&gt;
&lt;p&gt;NVIDIA 驱动安装的重点在于关闭系统本身默认运行的 nouveau 模块。&lt;/p&gt;
&lt;p&gt;首先上参考文章吧。&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;http://enetq.blog.51cto.com/479739/591622&quot;&gt;文章一&lt;/a&gt;还有&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;http://www.ideasr.com/thread-33171-1-1.html&quot;&gt;文章二&lt;/a&gt;。两篇文章的方法略有不同，我综合了一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://nerd-is.in/tags/Linux/"/>
    
  </entry>
  
</feed>
