<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> dagger.android——Android 中使用 Dagger2 的新方法 · 小憩之地</title><meta name="description" content="dagger.android——Android 中使用 Dagger2 的新方法 - Loong_T"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://nerd-is.in/rss.xml" title="小憩之地"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/talentloong" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Loong-T" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/rss.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">dagger.android——Android 中使用 Dagger2 的新方法</h1><div class="post-info">Jul 9, 2017</div><div class="post-content"><p>不打算讲解 Dagger2 的基础知识。</p>
<p>原先在 Android 项目中使用 Dagger2，准备好了 Component 和 Module 之后，在 Activity 或者 Fragment 里大概是这么使用的：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppComponent</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component</span>(modules = &#123;</span><br><span class="line">        AppModule.class,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MainActivityComponent.<span class="function">Builder <span class="title">mainComponentBuilder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(ThisApplication application)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MainActivityComponent</span></span><br><span class="line"><span class="meta">@ActivityScope</span></span><br><span class="line"><span class="meta">@Subcomponent</span>(modules = &#123;</span><br><span class="line">        MainActivityModule.class,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainActivityComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity mainActivity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subcomponent</span>.Builder</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="function">Builder <span class="title">mainModule</span><span class="params">(MainActivityModule mainModule)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">MainActivityComponent <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 MainActivity 中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupActivityComponent</span><span class="params">(AppComponent appComponent)</span> </span>&#123;</span><br><span class="line">    mainComponent = appComponent.mainComponentBuilder()</span><br><span class="line">            .mainModule(<span class="keyword">new</span> MainModule(<span class="keyword">this</span>))</span><br><span class="line">            .build();</span><br><span class="line">    mainComponent.inject(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码需要在生命周期方法中调用，之后才能正常使用被注入的对象。可以看到 MainActivity 需要知道自身是被 AppComponent 所注入，而被注入的类实际上不该了解（持有）注入者。<code>dagger.android</code> 就是为了在这一点上进行改进。</p>
<h2 id="先行知识"><a href="#先行知识" class="headerlink" title="先行知识"></a>先行知识</h2><p>在展示 <code>dagger.android</code> 之前，需要先了解一下 dagger 的 multibinding 功能，对于理解背后的运作机制有好处。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultibindingModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@IntoMap</span></span><br><span class="line">    <span class="meta">@StringKey</span>(<span class="string">"a"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">provideAValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"a value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@IntoMap</span></span><br><span class="line">    <span class="meta">@StringKey</span>(<span class="string">"b"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">provideBValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"b value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，能够产生一个 <code>Map&lt;String, String&gt;</code>，包含了两个 entry，值分别是 <code>a value</code> 和 <code>b value</code>。这个 Map 可以当成构造参数传入某个地方，也可以像下面的代码一样直接在 Component 中使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = MultibindingModule.class)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MultibindingComponent</span> </span>&#123;</span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">aMap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里应该大致会明白 <code>@IntoMap</code> 的作用了。搭配 <code>@StringKey</code> 注解，<code>@IntoMap</code> 可以将方法的返回值加入一个 Map。假如需要的 key 的类型不是 <code>String</code>，也可以使用其他的注解，或者自定义一个注解。</p>
<p>有了 multibinding 功能之后，实际上已经可以将最初的注入方案进行改进了。具体可以参考这篇文章<a href="https://medium.com/azimolabs/activities-subcomponents-multibinding-in-dagger-2-85d6053d6a95" target="_blank" rel="noopener">Activities Subcomponents Multibinding in Dagger 2</a>。</p>
<p><code>dagger.android</code> 在原理上是接近的，算是一种标准化。</p>
<h2 id="使用-dagger-android"><a href="#使用-dagger-android" class="headerlink" title="使用 dagger.android"></a>使用 <code>dagger.android</code></h2><p>以撰文时的最新版本 <code>2.11</code> 为例说明。假定我们的应用组织层次是 <code>Appliction &lt;-- MainActivity &lt;-- MainFragment</code>，这样方便说明。</p>
<p>第一件事是添加依赖。<code>dagger.android</code> 需要在原来的基础上再添加依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.google.dagger:dagger-android:2.11'</span></span><br><span class="line">implementation <span class="string">'com.google.dagger:dagger-android-support:2.11'</span> <span class="comment">// 如果使用 support library</span></span><br><span class="line">annotationProcessor <span class="string">'com.google.dagger:dagger-android-processor:2.11'</span></span><br><span class="line"><span class="comment">// kapt 'com.google.dagger:dagger-android-processor:2.11' // 使用 Kotlin kapt</span></span><br></pre></td></tr></table></figure>
<p>在 AppComponent 这一级，将 <code>AndroidInjectionModule</code> 加入 modules：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;</span><br><span class="line">        AndroidInjectionModule.class,</span><br><span class="line">        AppModule.class,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(ThisApplication application)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 MainActivity 这一层，首先确保使用的是 <code>@Subcomponent</code>，并且使 MainComponent 继承 <code>AndroidInjector&lt;T&gt;</code>。至于 <code>T</code> 的类型，这里需要被注入的是 MainActivity，所以就是 <code>MainActivity</code>。在 Subcomponent 内的 Builder，则需要继承 <code>AndroidInejector.Builder&lt;MainActivity&gt;</code>。由于 <code>AndroidInejector.Builder</code> 本身是抽象类，所以原本的 Builder 也需要改为抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subcomponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainActivityComponent</span> <span class="keyword">extends</span> <span class="title">AndroidInjector</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Subcomponent</span>.Builder</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">AndroidInjector</span>.<span class="title">Builder</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(subcomponents = MainActivityComponent.class)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivityModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binds</span></span><br><span class="line">    <span class="meta">@IntoMap</span></span><br><span class="line">    <span class="meta">@ActivityKey</span>(MainActivity.class)</span><br><span class="line">    <span class="keyword">abstract</span> AndroidInjector.Factory&lt;? extends Activity&gt;</span><br><span class="line">    bindActivityInjectorFactory(MainActivityComponent.Builder builder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中同时也新增了 MainActivityModule，Module 注解中将 subcomponents 指定为 MainActivityComponent。其他内容依葫芦画瓢。再将 MainActivityModule 添加到 AppComponent 中（感谢 <a href="https://github.com/xiaobailong24" target="_blank" rel="noopener">@xiaobailong24</a> 指出该处遗漏）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;</span><br><span class="line">        AndroidInjectionModule.class,</span><br><span class="line">        AppModule.class,</span><br><span class="line">        MainActivityModule.class,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(ThisApplication application)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，依赖部分已经编写完毕，接下来是使用依赖。修改自定义的 Application：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">HasActivityInjector</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> DispatchingAndroidInjector&lt;Activity&gt; dispatchingActivityInjector;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    DaggerApplicationComponent.create().inject(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AndroidInjector&lt;Activity&gt; <span class="title">activityInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatchingActivityInjector;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Application 实现了 HasActivityInjector，方法的实现仅是返回一个 dagger 为我们注入的对象。</p>
<p>最后在 Activity 中，在 <code>onCreate</code> 方法前，调用一个方法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    AndroidInjection.inject(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h2><p>最后实现注入的代码，无疑是 <code>AndroidInjection.inject(this)</code> 这一句，那么来看看这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    checkNotNull(activity, <span class="string">"activity"</span>);</span><br><span class="line">    Application application = activity.getApplication();</span><br><span class="line">    <span class="keyword">if</span> (!(application <span class="keyword">instanceof</span> HasActivityInjector)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                String.format(</span><br><span class="line">                        <span class="string">"%s does not implement %s"</span>,</span><br><span class="line">                        application.getClass().getCanonicalName(),</span><br><span class="line">                        HasActivityInjector.class.getCanonicalName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AndroidInjector&lt;Activity&gt; activityInjector =</span><br><span class="line">        ((HasActivityInjector) application).activityInjector();</span><br><span class="line">    checkNotNull(</span><br><span class="line">            activityInjector,</span><br><span class="line">            <span class="string">"%s.activityInjector() returned null"</span>,</span><br><span class="line">            application.getClass().getCanonicalName());</span><br><span class="line"></span><br><span class="line">    activityInjector.inject(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，就是从 Application 得到 ActivityInjector，调用 <code>inject</code> 方法注入这个 activity。Application 所持有的 <code>DispatchingAndroidInjector</code>，内部维护了一个 map。可以注意到，这个 map 的类型是 <code>Map&lt;Class&lt;? extends T&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends T&gt;&gt;&gt;</code>，并且构造方法使用了 <code>@Inject</code> 注解来注入这个 map。可知这个 map 便是我们使用 <code>@ActivityKey</code> 和 <code>@IntoMap</code> 所产生的。</p>
<p>AndroidInjector.Factory 的实现则是我们所写的 Subcomponent.Builder。通过 MainActivity.class 在 map 里得到对应的 AndroidInjector.Factory 后，就可以创建对应的 Component——也就是 AndroidInjector——接着就可以将 Component 所拥有的类型注入进 Activity 了。</p>
<h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><p>观察上面例子里的 MainActivityComponent，会发现这个接口的实际内容只有指定了 MainActivity 的类型，其他的部分都是固定的。减少 boilerplate code 是 dagger 的目的之一，所以针对这种情况，dagger 添加了一个 <code>@ContributesAndroidInjector</code> 注解，用来生成这样的 Subcomponent。</p>
<p><code>@ContributesAndroidInjector</code> 使用在 module 中的抽象方法上。该方法不该有参数，返回类型必须是 Activity、Fragment 和 Service 等 Android Framework 的类型。dagger 将会为这样的一个方法生成一个对应的 Subcomponent。这个注解还能接受一系列 Module 作为值，这些 module 将会成为所生成的 Subcomponent 的 module。</p>
<p>对应上面的例子，可以将 MainActivityComponent 文件删除，然后将 MainActivity 改为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivityModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ContributesAndroidInjector</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> MainActivity <span class="title">contributeMainActivity</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 ProGuard 时，需要加入如下规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># dagger</span><br><span class="line">-dontwarn dagger.android.**</span><br></pre></td></tr></table></figure>
<p>如果你想看实际使用的例子，可以参考我的 <a href="https://github.com/Loong-T/Android-Showcase" target="_blank" rel="noopener">Android Showcase</a>。</p>
<h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p><code>dagger</code> 的基础使用并不是很难。但在结合实际项目后，需要合理组织层级，考虑 Scope 的使用，配合上额外的 <code>Subcomponent</code> 等等，再加上 Android 独特的环境，往往会变得复杂而繁琐。而 <code>dagger.android</code> 很好地简化了 DI 的使用，能够将更多精力放到实际的应用上，个人推荐使用。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/07/16/ZXing-Android-Embedded-的使用以及自定义布局/" class="prev">上一篇</a><a href="/2017/02/19/迁移博客到-GitHub-Pages/" class="next">下一篇</a></div><div id="valine-comment"></div><div class="copyright"><p>© 2013 - 2019 <a href="http://nerd-is.in">Loong_T</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-39168233-1",'auto');ga('send','pageview');</script><script>new Valine({
    el: '#valine-comment' ,
    notify: false, 
    verify: false, 
    appId: 'cEx4KBVU7QN97j06EUqQkt0b-MdYXbMMI',
    appKey: 'WyXs7BDIEe5wqQmd1OJ6pvla',
    placeholder: '(ง •_•)ง 欢迎评论',
    path: window.location.pathname, 
    avatar:'identicon'
});</script></body></html>