<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>实用的 Flutter 国际化指南</title>
      <link href="/2019/03/02/%E5%AE%9E%E7%94%A8%E7%9A%84%20Flutter%20%E5%9B%BD%E9%99%85%E5%8C%96%E6%8C%87%E5%8D%97/"/>
      <url>/2019/03/02/%E5%AE%9E%E7%94%A8%E7%9A%84%20Flutter%20%E5%9B%BD%E9%99%85%E5%8C%96%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>作为一个 Android 开发者，Flutter 上来就让我把各类字符串写在 widget 里，其实我心里是拒绝的。硬编码是不可能硬编码的。国际化又不会，就是只能去看看文档，才能学点新姿势这样子。看了文档之后，觉得国际化这部分，还是有点麻烦的，我觉得有必要拎出来单独写写。</p><a id="more"></a><p>个人希望能把应用的字符串资源独立出来，以方便管理。至于支持多语言这种，反而是顺带完成的结果。本文以实用优先，因为我认为这部分内容是每个应用都需要使用的。</p><h2 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h2><p>首先简单认识一下 Flutter 国际化相关的知识点。</p><p>添加 <code>flutter_localizations</code> 依赖，让 Flutter 知道我们需要使用国际化相关的包。Flutter 自带的 widget 中，也用到了一些字符串资源，比如，<code>showSearch()</code> 方法打开的搜索栏提示。而这个包可以提供英文之外的，被 Flutter 内部默认使用的国际化字符串资源。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">flutter:</span></span><br><span class="line"><span class="attr">  sdk:</span> <span class="string">flutter</span></span><br><span class="line"><span class="attr">flutter_localizations:</span></span><br><span class="line"><span class="attr">  sdk:</span> <span class="string">flutter</span></span><br></pre></td></tr></table></figure><p>然后在创建 App 时，加入 <code>LocalizationsDelegate</code>，国际化的内容就由这些类来提供。<code>GlobalMaterialLocalizations.delegate</code> 提供了 Material 组件库所使用的字符串资源；<code>GlobalWidgetsLocalizations.delegate</code> 则定义了在当前的语言中，文字默认的排列方向。</p><p>之后我们定义了自己的国际化内容后，也需要加入到这个列表的头部。</p><p>还要声明要支持什么语言，<code>supportedLocales</code> 这里添加了英文和中文两种。如果说用户的语言不在这个列表内，则会默认使用列表第一项指定的语言。假如你对这个规则不满意，可以使用 <code>localeResolutionCallback</code> 参数来自定义自己想要的规则。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_localizations/flutter_localizations.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      localizationsDelegates: [</span><br><span class="line">        GlobalMaterialLocalizations.delegate,</span><br><span class="line">        GlobalWidgetsLocalizations.delegate,</span><br><span class="line">      ],</span><br><span class="line">      supportedLocales: [</span><br><span class="line">        <span class="keyword">const</span> Locale(<span class="string">'en'</span>, <span class="string">'US'</span>),</span><br><span class="line">        <span class="keyword">const</span> Locale(<span class="string">'zh'</span>, <span class="string">'CN'</span>),</span><br><span class="line">      ],</span><br><span class="line">      title: <span class="string">'App Title'</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: HomePage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们将一些自带的国际化资源加入到了应用中，Flutter 自身已经能够使用它们了。但我们要怎么使用它们呢？</p><p>通过 <code>MaterialLocalizations.of(context)</code> 获取到 <code>MaterialLocalizations</code> 的实例，然后访问里面的字符串。比如上面的 title 一行，可以替换为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onGenerateTitle: (context) =&gt; MaterialLocalizations.of(context).closeButtonLabel,</span><br></pre></td></tr></table></figure><p>注意这里将 title 替换成 onGenerateTitle 了，因为此时还在初始化 App 中，无法获取到 context，更无法通过 context 获取字符串了。</p><h2 id="自定义的国际化内容"><a href="#自定义的国际化内容" class="headerlink" title="自定义的国际化内容"></a>自定义的国际化内容</h2><p>现在来考虑怎么将我们自己的国际化加入到其中。也就是，需要在 <code>localizationsDelegates</code> 中加入自己的 <code>LocalizationsDelegate</code>。</p><p>查看文档，<code>LocalizationsDelegate</code> 需要一个泛型参数。参考官方的文档，可知这里指定的类型就是我们存放字符串的类。在这里，有两种选择：第一是基于 map 的，非常简单的实现；第二个则是通过 Dart 语言中专门负责国际化的 intl 包来实现。接下来我们按次来看看。</p><h3 id="基于-Map"><a href="#基于-Map" class="headerlink" title="基于 Map"></a>基于 Map</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleLocalizations</span> </span>&#123;</span><br><span class="line">  SimpleLocalizations(<span class="keyword">this</span>.locale);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Locale locale;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> SimpleLocalizations of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Localizations.of&lt;SimpleLocalizations&gt;(context, SimpleLocalizations);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&gt; _localizedValues = &#123;</span><br><span class="line">    <span class="string">'en'</span>: &#123;</span><br><span class="line">      <span class="string">'app_name'</span>: <span class="string">'App Name'</span>,</span><br><span class="line">      <span class="string">'hello_world'</span>: <span class="string">'Hello World'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'zh'</span>: &#123;</span><br><span class="line">      <span class="string">'app_name'</span>: <span class="string">'应用名'</span>,</span><br><span class="line">      <span class="string">'hello_world'</span>: <span class="string">'你好世界'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="keyword">get</span> _stringMap &#123;</span><br><span class="line">    <span class="keyword">return</span> _localizedValues[locale.languageCode];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> helloWorld &#123;</span><br><span class="line">    <span class="keyword">return</span> _stringMap[<span class="string">'hello_world'</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> appName &#123;</span><br><span class="line">    <span class="keyword">return</span> _stringMap[<span class="string">'app_name'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，这种方法的原理非常简单，就是将所有字符串放进 map，然后通过应用的 <code>Locale</code> 来取出对应语言的字符串。使用时，就是 <code>SimpleLocalizations.of(context).helloWorld</code> 这样来引用字符串。</p><p>其对应的 <code>LocalizationsDelegate</code> 如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleLocalizationsDelegate</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">LocalizationsDelegate</span>&lt;<span class="title">SimpleLocalizations</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> SimpleLocalizationsDelegate();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> isSupported(Locale locale) =&gt; [<span class="string">'en'</span>, <span class="string">'zh'</span>].contains(locale.languageCode);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;SimpleLocalizations&gt; load(Locale locale) &#123;</span><br><span class="line">    <span class="keyword">return</span> SynchronousFuture&lt;SimpleLocalizations&gt;(SimpleLocalizations(locale));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldReload(SimpleLocalizationsDelegate old) =&gt; <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要将这个 <code>SimpleLocalizationsDelegate</code> 加入到上面的 delegates 列表中，国际化就算完成了。</p><p>回看一下整个流程，并不算复杂，需要经手部分的原理也非常简单，只是一个 map 的使用。使用这个方法可以将整个应用的字符串都集中到一起管理。但是，维护起来还是很不方便。</p><h3 id="基于-intl"><a href="#基于-intl" class="headerlink" title="基于 intl"></a>基于 intl</h3><p>接下来看看基于 intl 包的实现方法是怎么样的。</p><p>第一步，添加依赖：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  intl:</span> <span class="string">^0.15.7</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line"><span class="attr">  intl_translation:</span> <span class="string">^0.17.3</span></span><br></pre></td></tr></table></figure><p>通过查看官方的例子，可以知道 <code>Intl.message()</code> 方法是我们管理字符串的关键。于是去看相关的文档，会发现——嗯，没有卵用（甚至没解释每个参数有什么作用）。</p><p>接下来还是一样添加一个跟 <code>SimpleLocalizations</code> 差不多类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntlLocalizations</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> IntlLocalizations of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Localizations.of&lt;IntlLocalizations&gt;(context, IntlLocalizations);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> appName &#123;</span><br><span class="line">    <span class="keyword">return</span> Intl.message(<span class="string">'App Name'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> helloWorld &#123;</span><br><span class="line">    <span class="keyword">return</span> Intl.message(<span class="string">'Hello world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从命令行中运行 <code>flutter pub pub run intl_translation:extract_to_arb --output-dir=你想要的输出目录 IntlLocalizations所在文件</code>。这一操作将会在指定目录里生成一个名为 intl_messages.arb 的文件，内容大致如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"@@last_modified"</span>: <span class="string">"2019-02-17T15:57:00.554988"</span>,</span><br><span class="line">  <span class="attr">"App Name"</span>: <span class="string">"App Name"</span>,</span><br><span class="line">  <span class="attr">"@App Name"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">    <span class="attr">"placeholders"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"Hello world"</span>: <span class="string">"Hello world"</span>,</span><br><span class="line">  <span class="attr">"@Hello world"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">    <span class="attr">"placeholders"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这个文件复制一份，命名为 intl_en.arb，作为英文版本使用。接着再复制一份，命名为 intl_zh.arb 作为中文版本使用。将 intl_zh.arb 的内容修改为对应中文的内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"@@last_modified"</span>: <span class="string">"2019-02-17T15:57:00.554988"</span>,</span><br><span class="line">  <span class="attr">"App Name"</span>: <span class="string">"应用名"</span>,</span><br><span class="line">  <span class="attr">"@App Name"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">    <span class="attr">"placeholders"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"Hello world"</span>: <span class="string">"你好世界"</span>,</span><br><span class="line">  <span class="attr">"@Hello world"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">    <span class="attr">"placeholders"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要其他语言的版本，请自行添加并修改。</p><p>再来输入一段长长的命令行：<code>flutter pub pub run intl_translation:generate_from_arb --output-dir=输出目录 --no-use-deferred-loading IntlLocalizations所在文件 所有arb文件</code>。这样会生成几个 <code>messages_</code> 开头的 dart 文件。可以自行查看一下里面的内容，我现在的 Dart 水平还比较菜，就先不分析其中的原理了。</p><p>其中名为 messages_all.dart 的文件里，生成了 <code>initializeMessages(String localeName)</code> 这个方法，将会在下面的步骤中使用到。</p><p>在 <code>IntlLocalizations</code> 中添加如下的方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Future&lt;IntlLocalizations&gt; load(Locale locale) &#123;</span><br><span class="line">  <span class="keyword">final</span> name =</span><br><span class="line">    locale.countryCode.isEmpty ? locale.languageCode : locale.toString();</span><br><span class="line">  <span class="keyword">final</span> localeName = Intl.canonicalizedLocale(name);</span><br><span class="line">  <span class="keyword">return</span> initializeMessages(localeName).then((_) &#123;</span><br><span class="line">    Intl.defaultLocale = localeName;</span><br><span class="line">    <span class="keyword">return</span> IntlLocalizations();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IntlLocalizations</code> 就准备完毕了。然后，开始实现 delegate，内容很简单：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntlLocalizationsDelegate</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">LocalizationsDelegate</span>&lt;<span class="title">IntlLocalizations</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> IntlLocalizationsDelegate();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> isSupported(Locale locale) =&gt; [<span class="string">'en'</span>, <span class="string">'zh'</span>].contains(locale.languageCode);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;IntlLocalizations&gt; load(Locale locale) &#123;</span><br><span class="line">    <span class="keyword">return</span> IntlLocalizations.load(locale);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldReload(IntlLocalizationsDelegate old) =&gt; <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就是正常使用流程了，这里不赘诉。回想整个流程，真正国际化的内容在 arb 文件中，对于集中管理字符串来说，比使用 map 还是好一点。但是整个流程还是显得异常麻烦，尤其是两次长得过分的命令行，明显应该由工具来改进。我相信 Flutter/Dart 团队应该会在这一点上做出优化。</p><h2 id="flutter-i18n"><a href="#flutter-i18n" class="headerlink" title="flutter_i18n"></a>flutter_i18n</h2><p>那么，有没有一款工具可以解救我们呢？您好，有的。</p><p>Android Studio（IDEA）上有一款名为 <a href="https://github.com/long1eu/flutter_i18n" target="_blank" rel="noopener">flutter_i18n</a> 的插件，可以帮助简化这个过程。其原理是通过 arb 文件来自动生成所需要的代码。</p><p>插件的使用非常简单，安装后会出现一个新的按钮。一旦你按下这个按钮——boom——插件就会根据 <code>res/values</code> 文件夹（Android 开发者觉得很亲切）中的 arb 文件，在 <code>lib/generated</code> 中生成 Dart 代码。</p><p>那么我们的重心就放在了 arb 文件上。Arb 文件全称是 Application Resource Bundle，是基于 JSON 的 balabala 接下去的我也不想接着说了，因为并不实用。还是来看下 Flutter 国际化中切实相关的部分。</p><p>虽然我们知道了 arb 文件是类 JSON 格式，但我们还并不清楚文件里具体需要什么样的内容。这里我们通过 <code>Intl.message()</code> 方法再重新认识一下。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> <span class="keyword">get</span> appName &#123;</span><br><span class="line">  <span class="keyword">return</span> Intl.message(</span><br><span class="line">    <span class="string">'App Name'</span>,</span><br><span class="line">    desc: <span class="string">'Name for the application'</span>,</span><br><span class="line">    name: <span class="string">'IntlLocalizations_appName'</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> hello(<span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="keyword">return</span> Intl.message(</span><br><span class="line">    <span class="string">'Hello <span class="subst">$name</span>'</span>,</span><br><span class="line">    name: <span class="string">'IntlLocalizations_hello'</span>,</span><br><span class="line">    desc: <span class="string">'Say hello to someone'</span>,</span><br><span class="line">    args: [name],</span><br><span class="line">    locale: <span class="string">'en'</span>,</span><br><span class="line">    examples: <span class="keyword">const</span> &#123;<span class="string">'name'</span>: <span class="string">'Someone'</span>&#125;,</span><br><span class="line">    meaning: <span class="string">'What is this?'</span>,</span><br><span class="line">    skip: <span class="keyword">false</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个更为详细的实现，其中 <code>hello</code> 方法将全部的参数都赋值了，以方便观察通过 <code>intl_translation</code> 包处理后的 arb 文件会是什么样的。</p><p>不过这之前简单介绍一下 <code>Intl.message()</code> 的部分参数。</p><ul><li><code>name</code> 参数必须与函数名一致，或者是<code>类名_方法名</code>这个形式——建议使用后者避免冲突；</li><li><code>args</code> 就是重复一遍参数；</li><li>如果方法没有参数，那么 <code>name</code> 和 <code>args</code> 可以省略；</li><li><code>desc</code> 参数就是描述这个字符串的字符串，必须是一个字符串字面量；</li><li><code>examples</code> 是参数的示例；</li><li><code>desc</code> 和 <code>examples</code> 在运行时不会被使用，但会被提取出来作为额外的信息提供给翻译人员作为参考；</li><li><code>skip</code> 如果为 true，那么这条记录就不会被提取出来；</li><li>其他的文档里并没有提。</li></ul><p>然后我们再运行一下那个很长的命令行，将其处理成 arb 文件看看：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"@@last_modified"</span>: <span class="string">"2019-02-18T21:31:28.750455"</span>,</span><br><span class="line">  <span class="attr">"IntlLocalizations_appName"</span>: <span class="string">"App Name"</span>,</span><br><span class="line">  <span class="attr">"@IntlLocalizations_appName"</span>: &#123;</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"Name for the application"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">    <span class="attr">"placeholders"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"IntlLocalizations_hello"</span>: <span class="string">"Hello &#123;name&#125;"</span>,</span><br><span class="line">  <span class="attr">"@IntlLocalizations_hello"</span>: &#123;</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"Say hello to someone"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">    <span class="attr">"placeholders"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: &#123;</span><br><span class="line">        <span class="attr">"example"</span>: <span class="string">"Someone"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，<code>meaning</code> 似乎没有用处。其核心就是 <code>&quot;IntlLocalizations_appName&quot;: &quot;App Name&quot;</code> 这样的一条一条的记录。以 @ 开头的部分，并不会真正在程序中使用，而是给翻译人员作为参考使用的。</p><p>这么一来，我们接下来就可以在 <code>res/values</code> 文件夹中创建需要的 arb 文件了。这个插件还提供了快捷创建 arb 文件的功能，只需要在 <code>res/values</code> 目录右键选择 New -&gt; Arb File 就可以选择这个 arb 文件的 locale 了。</p><p>需要注意的是，在这个插件中，如果字符串内需要包含变量，使用的语法是 <code>$var_name</code>，而不是上面例子里使用大括号的形式。</p><p>这里我创建了两个 arb 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// strings_en.arb</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"appName"</span>: <span class="string">"App Name"</span>,</span><br><span class="line">  <span class="attr">"hello"</span>: <span class="string">"Hello $name"</span></span><br><span class="line">&#125;</span><br><span class="line">// strings_zh_CN.arb</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"appName"</span>: <span class="string">"应用名"</span>,</span><br><span class="line">  <span class="attr">"hello"</span>: <span class="string">"你好$&#123;name&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用插件生成代码后，将 delegate 加入到应用的列表中，使用时也只要直接利用 <code>S</code> 这个类名来引用就好：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">    localizationsDelegates: [</span><br><span class="line">        S.delegate,</span><br><span class="line">        GlobalMaterialLocalizations.delegate,</span><br><span class="line">        GlobalWidgetsLocalizations.delegate,</span><br><span class="line">    ],</span><br><span class="line">    supportedLocales: [</span><br><span class="line">        <span class="keyword">const</span> Locale(<span class="string">'en'</span>, <span class="string">'US'</span>),</span><br><span class="line">        <span class="keyword">const</span> Locale(<span class="string">'zh'</span>, <span class="string">'CN'</span>),</span><br><span class="line">    ],</span><br><span class="line">    onGenerateTitle: (context) =&gt; S.of(context).appName,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>使用了这个插件之后，国际化就算得上方便了。生成的代码也可以稍微看一眼，或许有你用得到的其他方法。</p><p>最后提醒一句，由于生成代码是由插件完成的，所以依赖中的 <code>intl_translation</code> 可以删掉了。</p><h2 id="其他与总结"><a href="#其他与总结" class="headerlink" title="其他与总结"></a>其他与总结</h2><p>可能有的人会问，不使用 IDEA 的开发者，有没有什么更好的选择呢？或许有。现在还有一个名为 <a href="https://pub.dartlang.org/packages/rosetta" target="_blank" rel="noopener">rosetta</a> 的库，致力于解决 Flutter 国际化太过复杂的问题。我尝试过，但并没有跑通正常的流程，无法更多评价。有兴趣的朋友可以试试看。</p><p>到此，这篇指南就结束了，希望能对一些人有帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> International </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 FileProvider 共享文件</title>
      <link href="/2018/05/26/%E9%80%9A%E8%BF%87%20FileProvider%20%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/"/>
      <url>/2018/05/26/%E9%80%9A%E8%BF%87%20FileProvider%20%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>最近碰到一个异常，<code>android.os.FileUriExposedException: file://*** exposed beyond app through Intent.getData()</code>，了解了一下，原来是 Android 7.0（api level 24）开始，通过 URI 与其他应用共享文件要求 URI 必须是 <code>content://</code> 开头的形式。而 <a href="https://developer.android.com/reference/android/support/v4/content/FileProvider" target="_blank" rel="noopener">FileProvider</a> 是用来做这件事最简便的方法。</p><a id="more"></a><h1 id="声明-FileProvider"><a href="#声明-FileProvider" class="headerlink" title="声明 FileProvider"></a>声明 FileProvider</h1><p><code>FileProvider</code> 是 <code>ContentProvider</code> 的子类，所以需要在 <code>AndroidManifest.xml</code> 中进行声明。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"com.example.myapp.fileprovider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">"@xml/filepaths"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将 <code>android:grantUriPermissions</code> 设为 <code>true</code> 会允许得到访问这个 <code>FileProvider</code> 下所有数据的权限。</p><p><code>meta-data</code> 这部分将会在后面再细说，其他部分都是常规 <code>ContentProvider</code> 的内容。</p><h1 id="指定可访问的文件"><a href="#指定可访问的文件" class="headerlink" title="指定可访问的文件"></a>指定可访问的文件</h1><p>在上面的部分中，<code>meta-data</code> 里指定了一个 xml 的资源文件，这个文件便是用来指定可以被访问到的文件的。</p><p>在资源文件夹中创建一个 xml 资源文件，根元素如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>paths</code> 内可以添加如下的元素：</p><ul><li><code>&lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：代表应用内部存储的 <code>files/</code> 目录，也就是 <code>Context.getFilesDir()</code> 方法所得到的目录。</li><li><code>&lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Context.getCacheDir()</code> 方法得到的目录。</li><li><code>&lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：外部存储目录，与 <code>Environment.getExternalStorageDirectory()</code> 方法得到的结果一样。</li><li><code>&lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：对应 <code>Context.getExternalFilesDir(null)</code> 方法。</li><li><code>&lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>: 对应 <code>Context.getExternalCacheDir()</code> 方法。</li><li><code>&lt;external-media-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>: 对应 <code>Context.getExternalMediaDirs()</code> 方法。</li></ul><p>以上元素都有 <code>name</code> 和 <code>path</code> 两个属性。</p><p>我从 <code>path</code> 属性说起。<code>path</code> 即是真实的子目录地址段。比如 <code>&lt;files-path  path=&quot;docs/&quot; /&gt;</code> 对应的是 <code>files/docs/</code> 目录。那么，如果不想要子目录，而是当前目录呢？用 <code>.</code> 啊！</p><p>而 <code>name</code> 属性则是提供给外部应用的一个虚假的子目录地址段（在 content URI 中使用），主要是为了安全考虑。</p><h1 id="为-File-生成-Content-URI"><a href="#为-File-生成-Content-URI" class="headerlink" title="为 File 生成 Content URI"></a>为 File 生成 Content URI</h1><p>使用 <code>FileProvider.getUriForFile()</code> 方法就可以为在指定目录里的文件生成 content URI。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File imagePath = <span class="keyword">new</span> File(Context.getFilesDir(), <span class="string">"images"</span>);</span><br><span class="line">File newFile = <span class="keyword">new</span> File(imagePath, <span class="string">"default_image.jpg"</span>);</span><br><span class="line">Uri contentUri = FileProvider.getUriForFile(getContext(), <span class="string">"com.mydomain.fileprovider"</span>, newFile);</span><br></pre></td></tr></table></figure><p>上面这段代码，再加上如下的资源文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_images"</span> <span class="attr">path</span>=<span class="string">"images/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后得到的 content URI 会是：<code>content://com.mydomain.fileprovider/my_images/default_image.jpg</code>。</p><p>再回头来看一下。com.mydomain.fileprovider 是 ContentProvider 指定的 authority，同时也是 <code>getUriForFile()</code> 方法所需的参数。my_images 是 <code>files-path</code> 元素的 <code>name</code> 属性，将会映射到真实目录 images/，也就是 <code>path</code> 属性。</p><p>🙂这里，Android 又有了些小残念，在编写代码的时候无法保证资源文件的字符串和代码中的字符串是一致的。只能等到运行时才能知道。</p><h1 id="为-URI-获取临时访问权限"><a href="#为-URI-获取临时访问权限" class="headerlink" title="为 URI 获取临时访问权限"></a>为 URI 获取临时访问权限</h1><p>通过上面的步骤，我们已得到一个地址正确的 URI，但这个 URI 还不能被其他应用正常使用。有两种方式来给予临时性的读写权限。</p><p>第一是使用 <code>Context.grantUriPermission()</code> 方法。这个方法需要指定要分享应用的包名。然后传入 <code>Intent.FLAG_GRANT_READ_URI_PERMISSION</code> 和 <code>Intent.FLAG_GRANT_WRITE_URI_PERMISSION</code> 来指定要授予的权限。给予权限之后，可以使用 <code>Context.revokeUriPermission()</code> 来取消；或者等到机器重启之后，这一次的授权也会失效。</p><p>这个方法需要事先设置应用的包名，并不是很实用。</p><p>第二个方法：可以使用 <code>Intent.setFlags()</code> 方法设置上面提到的两个 flag，来授予读写权限。此时，需要将这个 URI 用 <code>Intent.setData()</code> 来当成数据传递。由于我们多半是使用 Intent 来传递 URI 的，所以这个方法比较实用。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>出于安全考虑，7.0 引入了这个机制。一来可以避免暴露应用内部的文件系统信息，二来不要求文件数据接收方拥有 <code>READ_EXTERNAL_STORAGE</code> 权限。出发点是好的，在实现上略有瑕疵，总体感觉还不错，建议使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> FileProvider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享两个颜色资源文件</title>
      <link href="/2017/07/17/%E5%88%86%E4%BA%AB%E4%B8%A4%E4%B8%AA%E9%A2%9C%E8%89%B2%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
      <url>/2017/07/17/%E5%88%86%E4%BA%AB%E4%B8%A4%E4%B8%AA%E9%A2%9C%E8%89%B2%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>当初看到 Material Design 那个 48 秒的<a href="https://www.youtube.com/watch?v=Q8TXgCzxEnw" target="_blank" rel="noopener">视频</a>的时候，我心里就有声音在大喊：“就是这个！我想要的就是这种设计！”</p><p>迄今已有三年多，MD 得到了不错的推广。然而能让我眼前一亮的设计却是寥寥。大量的应用纯粹套了一个 MD 的皮，用着提供的标准控件，但没有更为深入地去设计，显得非常枯燥干瘪。这种时候 MD 反而成了累赘。</p><a id="more"></a><p>细看 Android 上的 MD，由于 Android 的系统版本限制，为了照顾 4.X 的用户，通常不会过多使用 5.0 才有的功能，比如转场动画、阴影。但想要做出好看的设计，动画与阴影不可少。视频展示的内容，可以说是没有一秒脱离这两个要素。</p><p>动画实现不易，且放一边。而阴影倒是容易不少，希望能多多加上。没有阴影的辅助，应用会看起来没有层次感。但又会看到不少滥用 card 的情况，也是心累。</p><p>而大部分使用了 Material Design 的应用看起来都大同小异的原因，大概就是颜色了。官方提供了一个 color palette，算是标准颜色库。颜色数量不少，但推荐拿来当主色调的，只有 500 系列。那是多少种呢？19 种（还有黑白两色没有算入）。事实上会拿来用的，不过那些看起来舒服的颜色：蓝、绿、灰等，可选的颜色可谓少之又少。在这之外还要再选取一种 accent color，还要与主色调形成一定的对比，当然，也不能太瞎眼。所以能用的颜色组合并不多，你能看到的，大概大部分都是绿色、蓝灰色、蓝色的吧。这样怎么会不枯燥呢？</p><p>我个人很喜欢 MD 的动效和阴影，还有跟图片的巧妙搭配。但对于官方推荐的颜色，我并不是很认同。如果是用在控件上的、少量装饰性的颜色，我会直接在官方的 color palette 中挑选。但如果要决定一个应用的主色调，我会尽量避免使用。</p><p>终于要提到本文的主题了，就是我想要分享的两个颜色资源。一个来自<a href="http://nipponcolors.com/" target="_blank" rel="noopener">日本の伝統色</a>，我将里面的颜色提取成 Android 的资源文件，并且放在了 Gist 上。你可以在<a href="https://gist.github.com/Loong-T/ba3953685a2f3d32225468374ca3056f" target="_blank" rel="noopener">这里</a>找到。网站本身也很好看，可以去观摩下。这些颜色我觉得对眼睛很友好，看起来都挺舒服。另一个来自<a href="http://boxingp.github.io/traditional-chinese-colors/" target="_blank" rel="noopener">中国传统颜色</a>，我自己没有用过很多，不知道效果如何，算是附赠吧。你可以在<a href="https://gist.github.com/Loong-T/e204a3326bea1bccbdd4c581a1d1909f" target="_blank" rel="noopener">这里</a>访问到。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Resource </tag>
            
            <tag> Color </tag>
            
            <tag> Design </tag>
            
            <tag> Material Design </tag>
            
            <tag> 分享 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 颜色 </tag>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZXing Android Embedded 的使用以及自定义布局</title>
      <link href="/2017/07/16/ZXing-Android-Embedded-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/"/>
      <url>/2017/07/16/ZXing-Android-Embedded-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>想做个扫描条形码的功能，第一想到的就是 <a href="https://github.com/zxing/zxing/" target="_blank" rel="noopener">ZXing</a> 了。ZXing 的功能很强大，通常不需要完整把整个库都作为依赖放进应用里，而是分离出功能所需要的一部分。这类的文章、库还挺多的，这次看上的是 <a href="https://github.com/journeyapps/zxing-android-embedded" target="_blank" rel="noopener">ZXing Android Embedded</a>，大体上满足了我的需要。然而这个库也算是继承了 ZXing 的传统，文档不全面。这里稍微写一下使用的方法，并且对 ViewfinderView 的布局进行一定的改进。</p><a id="more"></a><h2 id="关键-View-的介绍"><a href="#关键-View-的介绍" class="headerlink" title="关键 View 的介绍"></a>关键 View 的介绍</h2><p>恕我不再介绍 <code>IntentIntegrator</code> 或者是 <code>DecoratedBarcodeView</code> 的用法，这可以在文档和示例中找到用法。</p><p><img src="/uploads/blog_pics/zxing-android-embadded-pic-1.png" alt="ZXing android embedded pic"></p><p>搭配官方示例的图来介绍下几个比较关键的 View。事实上并没有什么难点，但因为文档不全面，需要试过才能实际知道相关的内容。</p><p>图中的内容很简单，就是一个 DecoratedBarcodeView，而这个 View 实际上是由 BarcodeView、ViewfinderView 和一个 TextView 组合而成的。TextView 显示了底部的文字。ViewfinderView 绘制了周边半透明的黑色遮罩，中间的红线，扫描时出现的黄点，以及扫描成功后的结果。BarcodeView 负责调用相机进行扫描，并且也负责绘制相机拍到的内容，也就是被 ViewfinderView 覆盖在下面的内容。</p><p>假如，你想要的功能只是单纯地扫描，你只需要 BarcodeView。那么来看看 BarcodeView 怎么使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.journeyapps.barcodescanner.BarcodeView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/zxing_barcode_surface"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:zxing_framing_rect_width</span>=<span class="string">"220dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:zxing_framing_rect_height</span>=<span class="string">"220dp"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到有两个自定义的属性，指定了扫描区域的大小。这个扫描区域，就是上图中，没有被半透明遮罩盖住的部分。前面也说了，黑色遮罩实际上是由 ViewfinderView 绘制的。所以在单用 BarcodeView 时，是“看”不出来这两个属性的作用的。但有实际的效果，比如会影响到可能的点的坐标、扫描结果得到的 Bitmap。</p><p>进行扫描也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">barcodeView.decodeSingle(<span class="keyword">new</span> BarcodeCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">barcodeResult</span><span class="params">(BarcodeResult result)</span> </span>&#123;</span><br><span class="line">        textView.setText(<span class="string">"Scan result: "</span> + result.getText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">possibleResultPoints</span><span class="params">(List&lt;ResultPoint&gt; resultPoints)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码就进行了单次的扫描，<code>barcodeResult</code> 方法将会在扫描成功后被调用，得到扫描的结果。BarcodeResult 比较常用的是 <code>getText()</code> 和 <code>getBitmap()</code>，分别获取扫描的文字结果以及扫描成功时的图像。除了单次扫描，还有 <code>decodeContinuous(BarcodeCallback)</code> 方法，可以连续扫描多次，使用上大同小异。</p><p><code>possibleResultPoints()</code> 方法将会传递一些跟扫描有关的点的信息，通常是给 ViewfinderView 使用的。在上图中有一个小黄点，也就是这个方法里得到的。</p><p>除了上面提到的方法外，BarcodeView 还有 <code>pause()</code> 和 <code>resume()</code> 方法。见到这个名字大概就明白什么作用了。由于 BarcodeView 使用了相机，并且解析工作也有相当的计算量，所以在生命周期中需要调用这两个方法。从视觉的效果上来说，<code>pause()</code> 方法将会停止整个 view 对于相机拍摄内容的不断重绘，所以当你觉得需要固定 BarcodeView 显示的内容时，也可以调用这个方法。</p><p>然后强调一下：<strong>使用 BarcodeView 前，记得请求相机权限</strong>。</p><p>再来说说 ViewfinderView。ViewfinderView 本身没啥功能，主要提供 UI 上的辅助，给用户留下“我有在好好扫描啦”的印象。能够自定义遮罩、可能点、横线的颜色。通过 <code>setCamearaView()</code> 方法关联 BarcodeView，使得 ViewfinderView 能够获取到扫描区域的大小。</p><p><code>drawResultBitmap()</code> 方法可以将指定的 Bitmap 绘制在非遮罩的区域，有一个半透明的效果，并且停止横线和点的绘制。通常配合 BarcodeResult 使用。与之对应的，还有一个 <code>drawViewfinder()</code> 方法：清除掉 Bitmap 重新开始画跳动的横线。</p><h2 id="还有什么？"><a href="#还有什么？" class="headerlink" title="还有什么？"></a>还有什么？</h2><p>说真的，使用 ZXing Android Embedded 来将扫描功能集成到应用里可说是非常容易。但是——但是，想要进行自定义的布局却是相当困难。</p><p>记得前面提到的 BarcodeView 的扫描区域吗？我们看不到，但它实际存在着并且发挥着作用。我们能够指定它的大小，但是，我们不能指定它的位置。这个扫描区域永远是在 BarcodeView 的正中间的！</p><p>虽然 BarcodeView 的扫描区域是看不见的，但 ViewfinderView 的非遮罩区域却是实际可见的。假如想要把这个区域移动一下位置，该怎么办？</p><p>我鼓捣了一阵子，重新写了个 ViewfinderView，总体来说能够满足我个人的布局要求了。但还有比较明显的缺陷，因为没有修改 CameraView，所以对扫描区域实际上没有改动。导致得到的扫描结果，跟画面上的区域会不一致。如果不使用 <code>drawResultBitmap()</code> 方法的话，显示上就没有太大的问题。如果自定义的区域偏离中心区域太远的话，不建议使用，因为可能会出现扫描不准的情况。由于时间上不允许，暂时只能做出这样的妥协，只能将来有机会的时候再更深入定制了。那样的话，说不定直接在 ZXing 的基础上进行修改还更方便。</p><p>添加了 <code>vfv_frameGravity</code> 的属性，可以指定非遮罩区域（也就是视觉上的扫描区域）的位置，有 center、centerHorizontal 和 centerVertical 三个值可选。同时将 paddingTop 和 paddingLeft 加入到布局的计算中。这两者之间，frameGravity 优先于 padding。</p><p><img src="/uploads/blog_pics/configrable-viewfinderview-pic.png" alt="configrable viewfinderview pic"></p><p>举例来说，上图的效果设置了 centerHorizontal 进行水平居中，此时如果再设置 paddingLeft 是不会起作用的。在垂直方向上，是通过 paddingTop 设置了 110dp。</p><p>我重写的 ViewfinderView 项目在[这儿][configurable-viewfindderview]，里面附带了示例。可以通过 <a href="https://jitpack.io/" target="_blank" rel="noopener">Jitpack</a> 来使用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ...</span><br><span class="line">        maven &#123; url <span class="string">'https://jitpack.io'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compile <span class="string">'com.github.loong-t:configurable-viewfinderview:1.0.0'</span></span><br></pre></td></tr></table></figure><p>现在对这个 View 的功能还不是很满意，只能是供参考的程度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ZXing </tag>
            
            <tag> 扫码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dagger.android——Android 中使用 Dagger2 的新方法</title>
      <link href="/2017/07/09/dagger-android%E2%80%94%E2%80%94Android-%E4%B8%AD%E4%BD%BF%E7%94%A8-Dagger2-%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95/"/>
      <url>/2017/07/09/dagger-android%E2%80%94%E2%80%94Android-%E4%B8%AD%E4%BD%BF%E7%94%A8-Dagger2-%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>不打算讲解 Dagger2 的基础知识。</p><p>原先在 Android 项目中使用 Dagger2，准备好了 Component 和 Module 之后，在 Activity 或者 Fragment 里大概是这么使用的：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppComponent</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component</span>(modules = &#123;</span><br><span class="line">        AppModule.class,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MainActivityComponent.<span class="function">Builder <span class="title">mainComponentBuilder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(ThisApplication application)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MainActivityComponent</span></span><br><span class="line"><span class="meta">@ActivityScope</span></span><br><span class="line"><span class="meta">@Subcomponent</span>(modules = &#123;</span><br><span class="line">        MainActivityModule.class,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainActivityComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity mainActivity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subcomponent</span>.Builder</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="function">Builder <span class="title">mainModule</span><span class="params">(MainActivityModule mainModule)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">MainActivityComponent <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 MainActivity 中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupActivityComponent</span><span class="params">(AppComponent appComponent)</span> </span>&#123;</span><br><span class="line">    mainComponent = appComponent.mainComponentBuilder()</span><br><span class="line">            .mainModule(<span class="keyword">new</span> MainModule(<span class="keyword">this</span>))</span><br><span class="line">            .build();</span><br><span class="line">    mainComponent.inject(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码需要在生命周期方法中调用，之后才能正常使用被注入的对象。可以看到 MainActivity 需要知道自身是被 AppComponent 所注入，而被注入的类实际上不该了解（持有）注入者。<code>dagger.android</code> 就是为了在这一点上进行改进。</p><h2 id="先行知识"><a href="#先行知识" class="headerlink" title="先行知识"></a>先行知识</h2><p>在展示 <code>dagger.android</code> 之前，需要先了解一下 dagger 的 multibinding 功能，对于理解背后的运作机制有好处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultibindingModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@IntoMap</span></span><br><span class="line">    <span class="meta">@StringKey</span>(<span class="string">"a"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">provideAValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"a value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@IntoMap</span></span><br><span class="line">    <span class="meta">@StringKey</span>(<span class="string">"b"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">provideBValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"b value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，能够产生一个 <code>Map&lt;String, String&gt;</code>，包含了两个 entry，值分别是 <code>a value</code> 和 <code>b value</code>。这个 Map 可以当成构造参数传入某个地方，也可以像下面的代码一样直接在 Component 中使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = MultibindingModule.class)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MultibindingComponent</span> </span>&#123;</span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">aMap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里应该大致会明白 <code>@IntoMap</code> 的作用了。搭配 <code>@StringKey</code> 注解，<code>@IntoMap</code> 可以将方法的返回值加入一个 Map。假如需要的 key 的类型不是 <code>String</code>，也可以使用其他的注解，或者自定义一个注解。</p><p>有了 multibinding 功能之后，实际上已经可以将最初的注入方案进行改进了。具体可以参考这篇文章<a href="https://medium.com/azimolabs/activities-subcomponents-multibinding-in-dagger-2-85d6053d6a95" target="_blank" rel="noopener">Activities Subcomponents Multibinding in Dagger 2</a>。</p><p><code>dagger.android</code> 在原理上是接近的，算是一种标准化。</p><h2 id="使用-dagger-android"><a href="#使用-dagger-android" class="headerlink" title="使用 dagger.android"></a>使用 <code>dagger.android</code></h2><p>以撰文时的最新版本 <code>2.11</code> 为例说明。假定我们的应用组织层次是 <code>Appliction &lt;-- MainActivity &lt;-- MainFragment</code>，这样方便说明。</p><p>第一件事是添加依赖。<code>dagger.android</code> 需要在原来的基础上再添加依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.google.dagger:dagger-android:2.11'</span></span><br><span class="line">implementation <span class="string">'com.google.dagger:dagger-android-support:2.11'</span> <span class="comment">// 如果使用 support library</span></span><br><span class="line">annotationProcessor <span class="string">'com.google.dagger:dagger-android-processor:2.11'</span></span><br><span class="line"><span class="comment">// kapt 'com.google.dagger:dagger-android-processor:2.11' // 使用 Kotlin kapt</span></span><br></pre></td></tr></table></figure><p>在 AppComponent 这一级，将 <code>AndroidInjectionModule</code> 加入 modules：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;</span><br><span class="line">        AndroidInjectionModule.class,</span><br><span class="line">        AppModule.class,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(ThisApplication application)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 MainActivity 这一层，首先确保使用的是 <code>@Subcomponent</code>，并且使 MainComponent 继承 <code>AndroidInjector&lt;T&gt;</code>。至于 <code>T</code> 的类型，这里需要被注入的是 MainActivity，所以就是 <code>MainActivity</code>。在 Subcomponent 内的 Builder，则需要继承 <code>AndroidInejector.Builder&lt;MainActivity&gt;</code>。由于 <code>AndroidInejector.Builder</code> 本身是抽象类，所以原本的 Builder 也需要改为抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subcomponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainActivityComponent</span> <span class="keyword">extends</span> <span class="title">AndroidInjector</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Subcomponent</span>.Builder</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">AndroidInjector</span>.<span class="title">Builder</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(subcomponents = MainActivityComponent.class)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivityModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binds</span></span><br><span class="line">    <span class="meta">@IntoMap</span></span><br><span class="line">    <span class="meta">@ActivityKey</span>(MainActivity.class)</span><br><span class="line">    <span class="keyword">abstract</span> AndroidInjector.Factory&lt;? extends Activity&gt;</span><br><span class="line">    bindActivityInjectorFactory(MainActivityComponent.Builder builder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中同时也新增了 MainActivityModule，Module 注解中将 subcomponents 指定为 MainActivityComponent。其他内容依葫芦画瓢。再将 MainActivityModule 添加到 AppComponent 中（感谢 <a href="https://github.com/xiaobailong24" target="_blank" rel="noopener">@xiaobailong24</a> 指出该处遗漏）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;</span><br><span class="line">        AndroidInjectionModule.class,</span><br><span class="line">        AppModule.class,</span><br><span class="line">        MainActivityModule.class,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(ThisApplication application)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，依赖部分已经编写完毕，接下来是使用依赖。修改自定义的 Application：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">HasActivityInjector</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> DispatchingAndroidInjector&lt;Activity&gt; dispatchingActivityInjector;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    DaggerApplicationComponent.create().inject(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AndroidInjector&lt;Activity&gt; <span class="title">activityInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatchingActivityInjector;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Application 实现了 HasActivityInjector，方法的实现仅是返回一个 dagger 为我们注入的对象。</p><p>最后在 Activity 中，在 <code>onCreate</code> 方法前，调用一个方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    AndroidInjection.inject(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h2><p>最后实现注入的代码，无疑是 <code>AndroidInjection.inject(this)</code> 这一句，那么来看看这个方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    checkNotNull(activity, <span class="string">"activity"</span>);</span><br><span class="line">    Application application = activity.getApplication();</span><br><span class="line">    <span class="keyword">if</span> (!(application <span class="keyword">instanceof</span> HasActivityInjector)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                String.format(</span><br><span class="line">                        <span class="string">"%s does not implement %s"</span>,</span><br><span class="line">                        application.getClass().getCanonicalName(),</span><br><span class="line">                        HasActivityInjector.class.getCanonicalName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AndroidInjector&lt;Activity&gt; activityInjector =</span><br><span class="line">        ((HasActivityInjector) application).activityInjector();</span><br><span class="line">    checkNotNull(</span><br><span class="line">            activityInjector,</span><br><span class="line">            <span class="string">"%s.activityInjector() returned null"</span>,</span><br><span class="line">            application.getClass().getCanonicalName());</span><br><span class="line"></span><br><span class="line">    activityInjector.inject(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，就是从 Application 得到 ActivityInjector，调用 <code>inject</code> 方法注入这个 activity。Application 所持有的 <code>DispatchingAndroidInjector</code>，内部维护了一个 map。可以注意到，这个 map 的类型是 <code>Map&lt;Class&lt;? extends T&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends T&gt;&gt;&gt;</code>，并且构造方法使用了 <code>@Inject</code> 注解来注入这个 map。可知这个 map 便是我们使用 <code>@ActivityKey</code> 和 <code>@IntoMap</code> 所产生的。</p><p>AndroidInjector.Factory 的实现则是我们所写的 Subcomponent.Builder。通过 MainActivity.class 在 map 里得到对应的 AndroidInjector.Factory 后，就可以创建对应的 Component——也就是 AndroidInjector——接着就可以将 Component 所拥有的类型注入进 Activity 了。</p><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><p>观察上面例子里的 MainActivityComponent，会发现这个接口的实际内容只有指定了 MainActivity 的类型，其他的部分都是固定的。减少 boilerplate code 是 dagger 的目的之一，所以针对这种情况，dagger 添加了一个 <code>@ContributesAndroidInjector</code> 注解，用来生成这样的 Subcomponent。</p><p><code>@ContributesAndroidInjector</code> 使用在 module 中的抽象方法上。该方法不该有参数，返回类型必须是 Activity、Fragment 和 Service 等 Android Framework 的类型。dagger 将会为这样的一个方法生成一个对应的 Subcomponent。这个注解还能接受一系列 Module 作为值，这些 module 将会成为所生成的 Subcomponent 的 module。</p><p>对应上面的例子，可以将 MainActivityComponent 文件删除，然后将 MainActivity 改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivityModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ContributesAndroidInjector</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> MainActivity <span class="title">contributeMainActivity</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 ProGuard 时，需要加入如下规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># dagger</span><br><span class="line">-dontwarn dagger.android.**</span><br></pre></td></tr></table></figure><p>如果你想看实际使用的例子，可以参考我的 <a href="https://github.com/Loong-T/Android-Showcase" target="_blank" rel="noopener">Android Showcase</a>。</p><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p><code>dagger</code> 的基础使用并不是很难。但在结合实际项目后，需要合理组织层级，考虑 Scope 的使用，配合上额外的 <code>Subcomponent</code> 等等，再加上 Android 独特的环境，往往会变得复杂而繁琐。而 <code>dagger.android</code> 很好地简化了 DI 的使用，能够将更多精力放到实际的应用上，个人推荐使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Dagger </tag>
            
            <tag> 依赖注入 </tag>
            
            <tag> DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迁移博客到 GitHub Pages</title>
      <link href="/2017/02/19/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0-GitHub-Pages/"/>
      <url>/2017/02/19/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0-GitHub-Pages/</url>
      
        <content type="html"><![CDATA[<p>最近补了一下 Web 方面的知识，心想着就顺带把博客重新鼓捣一下。</p><p>以前的博客——很久没更新了——是租了个便宜的虚拟主机，用 WordPress 搭的。并不懂 PHP，而且一段时间里也应该不会去学。如果我自己想要搞点自己想要的主题，实际练习一下自己的 Web 技术，会比较困难。付费也挺麻烦的，干脆就把这一个月几块钱也省了算了。</p><a id="more"></a><p>于是 GitHub Pages 成了首选，简单方便。因为是静态网站，想要自己练个手也很容易。</p><p>静态网站生成方面，我选用了 Hexo。GitHub 官方推荐 Jekyll，但由于想尝个鲜，就选用了比较火的 Hexo。然后发现 Hexo 是基于 Node 的，不禁想感叹 JS 和 Node 真是如日中天。</p><p>然后找了个看着顺眼的主题 <a href="https://material.viosey.com" target="_blank" rel="noopener">Material</a>。这个主题视觉设计上很棒，并不是常见的那些平庸丑陋的 Material Design。然而感觉在布局和功能的设计上还是不尽我意，争取更熟悉了之后自己造一个吧。好在主题提供了几种样式，其中的 Isolation 十分简洁美观，于是决定先使用这个。</p><p>稍微自定义了一下主题，现在正在写第一篇博文。接下来就是搞定部署和域名绑定。</p><p>再长远一点的计划，就是支持社会化评论系统和 Https 了。</p><p>原先的评论系统用的是多说。别的不说，默认很丑。由于也没打算把原先的数据转到这里来，加上不支持 Https，所以不打算再使用多说。Disqus 在国内被墙了，由于基本都是翻墙的，所以一直没注意到这点。好在了解到网易云跟帖是支持 Https 的，于是计划使用它。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《离水之鱼》</title>
      <link href="/2015/05/11/%E8%AF%BB%E3%80%8A%E7%A6%BB%E6%B0%B4%E4%B9%8B%E9%B1%BC%E3%80%8B/"/>
      <url>/2015/05/11/%E8%AF%BB%E3%80%8A%E7%A6%BB%E6%B0%B4%E4%B9%8B%E9%B1%BC%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="http://book.douban.com/subject/10773372/" target="_blank" rel="noopener">《离水之鱼》</a></p><p>个人评价：2 星。</p><p>并没有读完，过程中就感到有很多问题，想着这真是本鸡汤的反面示范。有了些想法后，就觉得是能够用来写点什么的。于是准备写个读后感，在准备阶段发觉，细看这本书更是糟糕。</p><p>尽量写一些个人对于鸡汤类型文字的想法。虽然每次深入去思考这些糟糕的鸡汤也会有所收获——主要是指为什么糟糕这方面，但相当耗费时间，并不值得这样的投入。所以最好这篇读后感能成为糟糕鸡汤文的最后一篇感想。</p><a id="more"></a><hr><p>首先来看看全书的结构。</p><p>目录的主体是以 Step 加数字开头的章节名称，然后前后加上前言、语录、致谢。没有更多的东西了。主要内容分为 7 章，说不上多，在没有二级结构的情况下，组成了一本 250 页略少的书，让我觉得有些微妙。</p><p>我列一下：</p><blockquote><p>前言<br>Step 1 找到真实的自我<br>Step 2 把独特之处当做诱饵<br>Step 3 找到同类<br>Step 4 用自己的方式，在别人的海洋里畅游<br>Step 5 把自己推到台前<br>Step 6 广撒网，常进步<br>Step 7 运用你的独特力量，吊到丰盈收获<br>离水之鱼精彩语录<br>致谢</p></blockquote><p>这个 Step 1~7，就是作者总结出的“离水鱼儿七步法”，用来帮助离水之鱼发现自己的独特潜力。从这一点上来看，结构紧扣主题，中规中矩。</p><p>而后在读的时候，会发现文中有二级标题格式的内容，但却怎么看都不像是二级标题。</p><p>因为懒，我就列个第一章的内容：</p><blockquote><p>Step 1 找到真实的自我<br>    了解自我是一辈子的事儿<br>    生活在恐惧当中，等于根本没有活过<br>    真实意味着言行一致，意味着真诚，毫不矫饰<br>    表达情绪，一定要选对时机<br>    这一生中，我们可以拥有不同的身份，拥有多种职业<br>    谈谈令你自豪的东西，不要博取同情，不要可以地“触动心弦”<br>    勇敢地展示自我，破除他人的成见<br>    为自己心怀歉意，别人会认为你是可怜虫<br>    当你跟别人都不一样的时候，你已经吸引了旁人的注意<br>    要知道自己适合什么、擅长什么<br>    即使在最阴暗的日子里，也会有光明<br>    如果你是一条离水鱼儿，感恩的心态不能少<br>    职场中的重要美德</p></blockquote><p>我誊抄这些小标题的时候，就快被气炸了：什么狗屁玩意儿！</p><p>首先可以肯定的是，翻译定然算不上高水准，也就是过了个通顺的坎儿。“即使在最阴暗的日子里，也会有光明”，这样的句子，以我这么没文化的人来，也该是翻成“黑暗中终能见光明”之类的。</p><p>先不论小标题想要表达的意思是否真的管用，来看小标题是不是真有表达出意思来吧。</p><p>最后一条，“职场中的重要美德”，这种表述方式，难道不是白写吗？至少请告诉我到底是什么美德吧？</p><p>“或许是太长了不好放在小标题内。”我这么猜测。</p><p>于是去看标题下的内容，第一句赫然便是：“重要提示：如果你不够真实，同事们一眼就能看穿。”</p><p>于是你把这句话直接放到小标题有什么不妥吗？！哦，是怕别人发现这其实跟前面的“真实意味着言行一致，意味着真诚，毫不矫饰”讲述的同一回事儿吗？</p><p>真是哔了狗了…</p><p>总结起来，上面提到了两个问题：不知所云、重复。</p><p>另外的问题有：无关、罗嗦。我也懒于细致挑刺。</p><hr><p>从内容的组织结构来看，我颇为怀疑作者是否真的了解如何解决问题。</p><p>当碰见一个问题后，正统的思维应当是去思考 what、how、why。</p><ul><li>What：问题是什么，问题中涉及的东西是什么。</li><li>How：解决的手段、途径。</li><li>Why：为什么这样是有效的，根据是什么。</li></ul><p>以上是我个人经验的粗浅总结，假若有所不妥，请不吝指教。</p><p>Step 1 的内容，实际上是“如何找到真实的自我”。</p><p>将上述思维套用在该问题上：</p><ul><li>What：什么是真实的自我？</li><li>Why：为什么要找到真实的自我？</li><li>How：怎么找到真实的自我？</li></ul><p>这样一来，行文的结构就清晰明了，也有理有据令人信服。</p><hr><p>但作者还是深知引人注意的要诀的：讲故事。全书穿插着大量的故事，自己的，别人的，总而言之就是各种成功人士的。</p><p>大概是出于加强说服力与代入感的考虑，大部分的故事都是使用第一人称来叙述的。但限于贫瘠的讲故事能力——或许是翻译的错——故事毫无吸引力，人物也毫无张力。只是单纯的例子而已，跟 1+1=2 并没有什么两样。而且故事的背景也与我个人的经历相距甚远，千篇一律。</p><p>我不是很待见鸡汤类型的书，因为大部分就是表达一个观点，然后举例子来支持自己的观点。但这些例子只能用来支持，无法证明该观点。</p><p>这些例子极有可能是经过挑选的。比如对于一个成功学的观点，作者挑了一个典型的例子，但却完全没有提到其他不支持该观点的例子。</p><p>很多鸡汤也太过暧昧不清了。以本书来说明，上面的提纲中提到“勇敢地展现自我”，却又说“表达情绪，一定要选对时机”。这不啻于说：“做事，要讲究‘度’。”</p><p>这观点本身并没有错，却是废话。大道理我想大部分人都明白，但这个“度”到底要如何平衡呢？这才是真正的问题啊。大部分鸡汤相当于在说：“买股票是可以赚大钱的，但前提是你要买对。”</p><p>啧，那到底怎么才能买对，你倒是告诉我啊。</p><hr><p>批判就完了。虽然读时心中想法千转，到著文时却像是完全没了头脑。而且写得也完全没有趣味。</p><p>我为什么要买这本书呢？</p><p>经不住购物优惠的诱惑，挑书的时候瞥见了书名——《离水之鱼 与众不同一族的生存法则》。还是不得不承认这个话题对于自觉离水之鱼的人，比如我，是非常有吸引力的。经过技术书籍的价格轰炸，对于这类书定价的想法，完全就是真便宜真便宜买买买。</p><p>不过事实证明这类书籍水分也充足得让我总是觉得“又是一笔亏本买卖”。</p><p>我买来看了一小部分后，发觉我与作者对于“离水之鱼”的理解是不一样的。</p><p>书中定义说：离水之鱼是指脱离了适合生存环境的鱼。适合别人生活的一般环境，对于这样的鱼来说，是无水环境。</p><p>而我自己的想法是，离水表示的并不是状态，而是向往。离水之鱼是那些渴望脱离水生存的人。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 SwipeRefreshLayout 中加入多个子 View</title>
      <link href="/2014/09/29/%E5%9C%A8%20SwipeRefreshLayout%20%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%A4%9A%E4%B8%AA%E5%AD%90%20View/"/>
      <url>/2014/09/29/%E5%9C%A8%20SwipeRefreshLayout%20%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%A4%9A%E4%B8%AA%E5%AD%90%20View/</url>
      
        <content type="html"><![CDATA[<p>2017-02-23 更新：旧文搬运。</p><p>SwipeRefreshLayout 是由官方提供的下拉刷新 Widget。最低在 v4 中可用。最近使用了一下，发现虽然是官方出品，但也还是不够理想。</p><p>原先尝试使用了 Android L 中提供的新支持库 RecyclerView，彼此之间的兼容性就不够好。（RecyclerView 在那是也是新库，bug 多多，现在当然没有这种情况了。）</p><p>后来因为需要实现滑动到底部自动加载更多数据的功能，把 RecyclerView 换回了 ListView。在打算添加 <a href="https://github.com/makovkastar/FloatingActionButton" target="_blank" rel="noopener">FloatingActionButton</a> 在同一画面上时，发现 SwipeRefreshLayout 不够方便。根据 FloatingActionButton 这个库的说明，需要将 FloatingActionButton 与 ListView 放在同一 ViewGroup 下。</p><a id="more"></a><p>但是 SwipeRefreshLayout 只能有一个子视图，不然就会丢异常。于是自然就会在 SwipeRefreshLayout 下加一个 ViewGroup 包装一层来解决这个问题。这样一来，抛出异常的问题是解决了。但是运行后发现，ListView 只能上滑，而不能下拉。一旦下拉，就会触发 SwipeRefreshLayout 的下拉刷新。</p><p>可想而知，这是在事件派发上出了问题。下拉的事件在通常情况下应该由 ListView 来进行处理；当 ListView 滚动位置位于顶部时，再由 SwipeRefreshLayout 来进行处理。而现在的情况是，所有下拉手势全都由 SwipeRefreshLayout 处理的。</p><p>查阅关于事件派发的资料后，也没有想到比较可行的解决方案。接下来去查看了一下 SwipeRefreshLayout 的源码，结果不怎么麻烦的就解决了。</p><p>根据事件派发的知识，在 SwipeRefreshLayout 中找到相关的方法 <code>onInterceptTouchEvent(MotionEvent ev)</code> 和 <code>onTouchEvent(MotionEvent ev)</code>。查看它们的代码，发现在onIntercreptTouchEvent中有这么一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isEnabled() || mReturningToStart || canChildScrollUp()) &#123;</span><br><span class="line">    <span class="comment">// Fail fast if we're not in a state where a swipe is possible</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，<code>canChildSrollUp()</code> 方法跟我的问题有密切关联。再追看 <code>canChildSrollUp()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Whether it is possible for the child view of this layout to</span></span><br><span class="line"><span class="comment"> *         scroll up. Override this if the child view is a custom view.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canChildScrollUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &lt; <span class="number">14</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTarget <span class="keyword">instanceof</span> AbsListView) &#123;</span><br><span class="line">            <span class="keyword">final</span> AbsListView absListView = (AbsListView) mTarget;</span><br><span class="line">            <span class="keyword">return</span> absListView.getChildCount() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (absListView.getFirstVisiblePosition() &gt; <span class="number">0</span> || absListView.getChildAt(<span class="number">0</span>)</span><br><span class="line">                            .getTop() &lt; absListView.getPaddingTop());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mTarget.getScrollY() &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ViewCompat.canScrollVertically(mTarget, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释中也说了，如果子视图是自定义的，那么重写这个方法即可。mTarget 就是 SwipeRefreshLayout 中默认的唯一的子视图。现在根据我的要求，继承 SwipeRefreshLayout 后，将这个方法改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canChildScrollUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &lt; <span class="number">14</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mScrollableChild <span class="keyword">instanceof</span> AbsListView) &#123;</span><br><span class="line">            <span class="keyword">final</span> AbsListView absListView = (AbsListView) mScrollableChild;</span><br><span class="line">            <span class="keyword">return</span> absListView.getChildCount() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (absListView.getFirstVisiblePosition() &gt; <span class="number">0</span> || absListView.getChildAt(<span class="number">0</span>)</span><br><span class="line">                    .getTop() &lt; absListView.getPaddingTop());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mScrollableChild.getScrollY() &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ViewCompat.canScrollVertically(mScrollableChild, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>mScrollableChild</code> 是由自己定义的，可以滚动的 View。</p><p>现在，下拉滚动的问题已经解决了。接下来就是要方便地指定这个 <code>mScrollableChild</code>。我希望在我自定义的 SwipeRefreshLayout 中，用 xml 的属性来指定一个id，然后将这个指定 id 的 View 加载到 <code>mScrollableChild</code> 上。</p><p>在 values 文件夹中新建一个 attrs.xml，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"ImprovedSwipeLayoutAttrs"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"scrollableChildId"</span> <span class="attr">format</span>=<span class="string">"reference"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>于是就可以如下代码一样使用了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">in.nerd_is.inactive_weibo.ui.ImprovedSwipeLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:fab</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:isl</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/swipe_container"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/md_blue_grey_50"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">isl:scrollableChildId</span>=<span class="string">"@+id/list_statuses"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"in.nerd_is.inactive_weibo.ui.StatusesFragment"</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/list_statuses"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:minHeight</span>=<span class="string">"?android:attr/listPreferredItemHeight"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingTop</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingBottom</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingLeft</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingRight</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:clipToPadding</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:divider</span>=<span class="string">"@android:color/transparent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:dividerHeight</span>=<span class="string">"12dp"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">com.melnykov.fab.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/button_floating_action"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">"bottom|right"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@drawable/ic_md_create"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">fab:fab_colorNormal</span>=<span class="string">"@color/md_blue_400"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">fab:fab_colorPressed</span>=<span class="string">"@color/md_blue_grey_500"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">in.nerd_is.inactive_weibo.ui.ImprovedSwipeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ImprovedSwipeLayout 全部代码如下，很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImprovedSwipeLayout</span> <span class="keyword">extends</span> <span class="title">SwipeRefreshLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = ImprovedSwipeLayout.class.getCanonicalName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mScrollableChildId;</span><br><span class="line">    <span class="keyword">private</span> View mScrollableChild;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImprovedSwipeLayout</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImprovedSwipeLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line"></span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(</span><br><span class="line">                attrs, R.styleable.ImprovedSwipeLayoutAttrs);</span><br><span class="line">        mScrollableChildId = a.getResourceId(R.styleable.ImprovedSwipeLayoutAttrs_scrollableChildId, <span class="number">0</span>);</span><br><span class="line">        mScrollableChild = findViewById(mScrollableChildId);</span><br><span class="line">        a.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canChildScrollUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ensureScrollableChild();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &lt; <span class="number">14</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mScrollableChild <span class="keyword">instanceof</span> AbsListView) &#123;</span><br><span class="line">                <span class="keyword">final</span> AbsListView absListView = (AbsListView) mScrollableChild;</span><br><span class="line">                <span class="keyword">return</span> absListView.getChildCount() &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; (absListView.getFirstVisiblePosition() &gt; <span class="number">0</span> || absListView.getChildAt(<span class="number">0</span>)</span><br><span class="line">                        .getTop() &lt; absListView.getPaddingTop());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mScrollableChild.getScrollY() &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ViewCompat.canScrollVertically(mScrollableChild, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureScrollableChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mScrollableChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mScrollableChild = findViewById(mScrollableChildId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中的 Task 和  Back stack</title>
      <link href="/2013/08/19/Android-%E4%B8%AD%E7%9A%84-Task-%E5%92%8C-Back-stack/"/>
      <url>/2013/08/19/Android-%E4%B8%AD%E7%9A%84-Task-%E5%92%8C-Back-stack/</url>
      
        <content type="html"><![CDATA[<p>2017-02-20 更新：旧文搬运。内容很浅显，但这部分内容实际上是需要好好掌握的，等以后会再充实一下。</p><p>在近来做的实战项目中，终于涉及到了这个方面的内容，那就趁机学一学用一用。</p><p>事实上，这方面的内容并不难理解，但是总让我感觉不知该怎么用才好。这里也就只能列一列几种模式，至于相应的解决方法，还是需要自己去琢磨试验。</p><a id="more"></a><p>下面的内容参考，都是来自官方文档。</p><p>Task 是用户在进行特定操作时调用的 activity 的一个集合。这些 activity 是由回退栈（back stack）来进行管理的，以打开的顺序来进行排列。</p><p>Home screen 是大多数 task 开始的地方。当用户在点击应用的图标时，该应用的 task 就来到了前台；如果还没有它的 task，则会新建一个。打开的 activity 则会被放在这个 stack 最底部（事实上也是在回退栈的最顶部，因为栈内只有这么一个元素）。</p><p>当在栈内的这个 activity 打开其他的 activity 时，新的 activity 会被被放置在栈的顶部，并且得到焦点。用户点击返回键后，当前的 activity 被销毁，同时也从栈中被弹出，此时在栈顶的 activity 被恢复。在回退栈中的 activity 是不可能进行重新排序的，只有栈的 push 和 pop 操作（LIFO）。</p><p>继续按返回键，task 中的 activity 将会依次被弹出，直到其中再没有 activity，这时，这个 task 也就不存在了。</p><p>用户开始一个新的 task 时，原来的 task 可以被移到后台，其中的所有 activity 都会停止，但回退栈保持完整。并且用户此时可以回到原来的 task，比如通过选择最近应用，或者是在主页再次点击开始那个应用。</p><p>需要注意的是，当运行了太多的 task 时，系统会开始销毁后台的 activity。被销毁的 activity 的状态将会丢失，但是 task 的回退栈不会丢失。</p><p>如果一个 activity 能在多个 activity 中被打开，由于回退栈不能被重新排序，此时这个回退栈中会出现这个 activity 的多个实例，甚至在多个 task 中被实例化多次。这时候再点击返回键，还是依旧将这些 activity 依次弹出，并且各自有各自的状态。如果不想 activity 被实例化多次，可以对这种行为进行更改。</p><h2 id="定义启动模式"><a href="#定义启动模式" class="headerlink" title="定义启动模式"></a>定义启动模式</h2><p>启动模式允许你定义新的 activity 实例与当前 task 的关系。有两种定义方法：</p><ol><li>使用 manifest 文件</li><li>使用 Intent 的 flags</li></ol><p><code>&lt;activity&gt;</code> 中可使用的属性：</p><ul><li>taskAffinity</li><li>launchMode</li><li>allowTaskReparenting</li><li>clearTaskOnLaunch</li><li>alwaysRetainTaskState</li><li>finishOnTaskLaunch</li></ul><p>flags 可使用的值：</p><ul><li>FLAG_ACTIVITY_NEW_TASK</li><li>FLAG_ACTIVITY_CLEAR_TOP</li><li>FLAG_ACTIVITY_SINGLE_TOP</li></ul><p>Intent 的 flags 方式优先于 manifest，但是，两个方式不能等同。某些效果只能通过在 manifest 中定义的启动模式实现，不能通过 flags 实现；反之亦然。</p><h3 id="使用-manifest-文件"><a href="#使用-manifest-文件" class="headerlink" title="使用 manifest 文件"></a>使用 manifest 文件</h3><p>使用 <code>&lt;activity&gt;</code> 元素中的 launchMode 属性。launchMode 属性可设为四种启动模式：</p><ul><li>standard<br>默认值。系统在启动 activity 的 task 中创建一个新的 activity 实例，并且将 intent 传送给它。该 activity 可以被实例化多次，各个实例可以属于不同的 task，一个 task 中也可以存在多个实例。</li><li>singleTop<br>如果 activity 已经存在一个实例并位于当前 task 的栈顶，则系统会调用已有实例的 <code>onNewIntent()</code> 方法把 intent 传递给已有实例，而不是创建一个新的实例。activity 可以被实例化多次，各个实例可以属于不同的 task，一个 task 中可以存在多个实例（但仅当栈顶的实例不是该 activity 的）。</li><li>singleTask<br>系统将创建一个新的 task，并把 activity 实例作为根放入其中。但是，如果 activity 已经在其它 task 中存在实例，则系统会通过调用其实例的 <code>onNewIntent()</code> 方法把 intent 传给已有实例，而不是再创建一个新实例。 此 activity 同一时刻只能存在一个实例。</li><li>singleInstance<br>除了系统不会把其它 activity 放入当前实例所在的 task 之外，其它均与 singleTask 相同。 无论 activity 是在一个新的 task 中启动，还是位于其它已有的 task 中，用户总是可以用回退键返回到前一个 activity 中。 但是，如果你启动了一个启动模式设为singleTask的 activity，且有一个后台 task 中已存在实例的话，则这个后台 task 就会整个转到前台。 这时，当前的回退栈就包含了这个转入前台的 task 中所有的 activity，位置是在栈顶。</li></ul><h3 id="使用Intent标志"><a href="#使用Intent标志" class="headerlink" title="使用Intent标志"></a>使用Intent标志</h3><p>这个标志可以修改的默认模式包括：</p><ul><li>FLAG_ACTIVITY_NEW_TASK<br>在新的 task 中启动 activity。如果要启动的 activity 已经运行于某 task 中，则那个 task 将调入前台，最后保存的状态也将恢复，activity 将在 <code>onNewIntent()</code> 中接收到这个新 intent。 这个过程与前一节所述的  singleTask 模式相同。</li><li>FLAG_ACTIVITY_SINGLE_TOP<br>如果要启动的 activity 就是当前 activity（位于回退栈顶），则已存在的实例将接收到一个 <code>onNewIntent()</code> 调用，而不是创建一个 activity 的新实例。 这个过程与前一节所述的 singleTop 模式相同。</li><li>FLAG_ACTIVITY_CLEAR_TOP<br>如果要启动的 activity 已经在当前 task 中运行，则不再启动一个新的实例，且所有在其上面的 activity 将被销毁，然后通过 <code>onNewIntent()</code> 传入 intent 并恢复 activity（不在栈顶）的运行。 此种模式在launchMode中没有对应的属性值。FLAG_ACTIVITY_CLEAR_TOP 常与 FLAG_ACTIVITY_NEW_TASK 一起使用。这表示先定位其它 task 中已存在的 activity，再把它放入可以响应 intent 的位置。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Task </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 EasyBCD 引导 CentOS</title>
      <link href="/2013/03/09/%E4%BD%BF%E7%94%A8-EasyBCD-%E5%BC%95%E5%AF%BC-CentOS/"/>
      <url>/2013/03/09/%E4%BD%BF%E7%94%A8-EasyBCD-%E5%BC%95%E5%AF%BC-CentOS/</url>
      
        <content type="html"><![CDATA[<p>2017-02-20 更新：旧文搬运、修缮。我记得 Win8 开始，使用了比较棘手的引导系统，不知现在这方法是否还有效。</p><p>昨晚重启后忽然进不了 Windows，各种搜索加各种尝试后依旧无果，不得已只能使用 PE 修复 MBR 的引导。</p><p>这个办法是我尽力避免的，因为修复后会把 GRUB 覆盖掉，那么我就无法进入 Linux 系统了。这之后修复 Linux 的引导又是一番额外功夫。以前也算是碰见过类似的问题，当时用了 EasyBCD 这个软件来引导系统，所以这一次也立马想到了这个软件。不过还是碰见了不少问题，一上午才真正解决了这个问题。经验难得，需要记录一下。</p><a id="more"></a><p>以前用 EasyBCD 的时候，纯粹是乱折腾，多加几个不同的引导，直白地碰运气，问题也解决了。但这一次没有这么好的人品。这次安装系统的时候把 /boot 单独挂载到一个分区上，猜测这就是以前的方法不奏效的原因。</p><p>经过这一次的折腾，对系统的引导算是多了一些理解。其中各种曲折，各种重启，写一下正确的解决办法。</p><p>参考文献有：<a href="http://wenku.baidu.com/view/2367b2d926fff705cc170a48.html" title="百度文库资料" target="_blank" rel="noopener">百度文库的一篇</a>（这个是重点），<a href="http://neosmart.net/wiki/display/EBCD/NeoGrub" title="EasyBCD 官方文档" target="_blank" rel="noopener">EasyBCD 官方文档</a>，<a href="http://baike.baidu.com/view/225343.htm" title="Grub 百科" target="_blank" rel="noopener">GRUB 的百度百科</a>。</p><hr><p>安装好 EasyBCD 后，添加引导，选择 NeoGrub，安装，配置。这时候出现使用记事本打开的 menu.lst，这里要添加的就是关键了。</p><p>首先来看看官方给出的Ubuntu引导实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">titleUbuntu Gutsy Gibbon    </span><br><span class="line">root(hd1,2)    <span class="comment">#Load Ubuntu from the 2nd harddrive's 3rd partition.</span></span><br><span class="line"><span class="comment">#Next Line: Translate (hd1,2) to Linux notation and set that as the root partition</span></span><br><span class="line">kernel/boot/vmlinuz-2.6.22-14-generic root=/dev/sdbc</span><br><span class="line">initrd/boot/initrd.img-2.6.22-14-generic</span><br></pre></td></tr></table></figure><p>title 是引导系统的名字，自己写一个能辨认的就好。</p><p>root 这一行是装载指定的分区，如果装载的分区不正确，那么下面指定的文件自然就不能被找到，引导自然失败。root 后有一个空格，括号内是第几个硬盘的第几个分区。hd0 是第一块硬盘，0 是这一块硬盘的第一个分区，依次类推。这里需要装载的是 /boot 所在的分区。</p><p>kernel 行指定 Linux 的内核，位置在 /boot 下，名字一般是以 vmlinuz 开头的一个文件。如果 /boot 是单独挂载，位置应该类似：<code>/vmlinuz-2.6.22-14-generic</code>。</p><p>如果不知道内核的名称，重启进入 NeoGrub，按 c 进入命令行模式，使用 root 命令装载分区后可以使用 TAB 键列出文件或命令。请注意这个功能，下面的 initrd 文件也需要使用相同的方法来获得。内核名字后的 <code>root=***</code> 必不可少，我在这里栽了很久。有一些 Linux 下硬盘相关知识的应该不难理解这一句。不是很清楚的请参考<a href="http://vbird.dic.ksu.edu.tw/linux_basic/0130designlinux_2.php" title="鸟哥的 Linux 私房菜" target="_blank" rel="noopener">鸟哥的相关内容</a>。<code>/dev/sd??</code> 这个其实指的就是根目录/所在的分区。</p><p>initrd 也是一个文件，与内核 vmlinuz 同在 /boot 下。名称可能是 initrd 开头的一个文件，但也可能是 initramfs 开头的一个 img 文件，在我的系统上就是如此。</p><p>在这之后可能还需要添加一句 boot 命令。</p><p>这里说明一下我的误区。因为我的 /boot 是单独挂载的，所以不能同时用 root 命令装载 <code>/</code> 和 <code>/boot</code>。让我对怎么指定 <code>root=</code> 后的根目录很伤脑筋。在我查看 GRUB 的百度百科的时候，学习到在加载了内核文件后，/boot 等就已经挂载到根目录下了。所以只需要使用<code>root=/dev/sd??</code> 这样的写法来指定就好了，而不必考虑自己在 GRUB 中装载的是哪一个分区。</p><p>下面是我成功引导的menu.lst文件，供参考：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NeoSmart NeoGrub Bootloader Configuration File</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is the NeoGrub configuration file, and should be located at C:\NST\menu.lst</span></span><br><span class="line"><span class="comment"># Please see the EasyBCD Documentation for information on how to create/modify entries:</span></span><br><span class="line"><span class="comment"># http://neosmart.net/wiki/display/EBCD/</span></span><br><span class="line"></span><br><span class="line">default 0</span><br><span class="line">timeout 8</span><br><span class="line"></span><br><span class="line">title CentOS 6.3</span><br><span class="line">    root (hd0,4)</span><br><span class="line">    kernel /vmlinuz-2.6.32-279.el6.x86_64 root=/dev/sda8</span><br><span class="line">    initrd /initramfs-2.6.32-279.el6.x86_64.img</span><br><span class="line">    boot</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 与 Ubuntu 下安装 NVIDIA 驱动</title>
      <link href="/2013/03/07/CentOS-%E4%B8%8E-Ubuntu-%E4%B8%8B%E5%AE%89%E8%A3%85-NVIDIA-%E9%A9%B1%E5%8A%A8/"/>
      <url>/2013/03/07/CentOS-%E4%B8%8E-Ubuntu-%E4%B8%8B%E5%AE%89%E8%A3%85-NVIDIA-%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>2017-02-20 更新：旧文搬运，略加修缮，觉得还实用，所以保留下来。<br>2013-08-29 更新：Ubuntu 下安装方法，详见最下。</p><p>NVIDIA 驱动安装的重点在于关闭系统本身默认运行的 nouveau 模块。</p><p>首先上参考文章吧。<a href="http://enetq.blog.51cto.com/479739/591622" target="_blank" rel="noopener">文章一</a>还有<a href="http://www.ideasr.com/thread-33171-1-1.html" target="_blank" rel="noopener">文章二</a>。两篇文章的方法略有不同，我综合了一下。</p><a id="more"></a><p>去 Nvidia 官网下载对应的显卡驱动，我下载的驱动文件名为：NVIDIA-Linux-x86_64-310.32.run。</p><p>这部分操作大量使用 root 权限，所以最好还是使用 root 身份来进行。</p><p>第一步需要关闭 X Windows，运行：<code>init 3</code>。</p><p>如果现在运行驱动安装程序 <code>sh NVIDIA-Linux-x86_64-310.32.run</code>，有可能会提示你：</p><blockquote><p>ERROR: The Nouveau kernel driver is currently in use by your system. This  driver is incompatible with the NVIDIA driver, and must be disabled  before proceeding.</p></blockquote><p>意思就是 nouveau 这个模块正在运行中，该模块与NVIDIA驱动不兼容，必须要被禁用才可以进行。为了禁用这个模块，大费周折，找了不少资料文章，总算试验出有效的方法。</p><p>过程中也看见一些传说，说是某些 Linux 发行版本禁用该模块也不算麻烦，但是 CentOS 似乎并不在那个阵营里。</p><p><strong>更新：添加 blacklist 或许没有什么影响，可以选择跳过这部分，直接到修改 <code>/etc/grub.conf</code> 文件部分。</strong></p><p>编辑 <code>/etc/modprobe.d/blacklist.conf</code>，在某处（但是不要选在注释里）加上 <code>blacklist nouveau</code>。</p><p>然后下面一步我估计可以选做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 备份 the initramfs file</span><br><span class="line">mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r).img.bak</span><br><span class="line">* 重新建立 the initramfs file</span><br><span class="line">dracut -v /boot/initramfs-$(uname -r).img $(uname -r)</span><br></pre></td></tr></table></figure><p>如果你运行了上面的两句命令，那请记好你曾经备份过 initramfs 这个文件。如果以后出错，可以还原试试。</p><p>在 CentOS 里似乎必须还需要下面这一步。因为我单独试了上面两步后并没有效果。</p><p>编辑 <code>/etc/grub.conf</code> 文件，禁止 nouveau KMS 的使用。</p><p>在这个文件里找到现在所在的系统项目，应该形如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title CentOS (2.6.32-279.el6.x86_64)</span><br><span class="line">        root (hd0,4)</span><br><span class="line">        kernel /vmlinuz-2.6.32-279.el6.x86_64 ro root=UUID=55151a0d-b460-462b-b5c6-97dfd4a3d328 rd_NO_LUKS  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_MD LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet</span><br><span class="line">        initrd /initramfs-2.6.32-279.el6.x86_64.img</span><br></pre></td></tr></table></figure><p>在 kernel 行的最后加上 <code>nouveau.modeset=0</code>。加上后的文件应该如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title CentOS (2.6.32-279.el6.x86_64)</span><br><span class="line">        root (hd0,4)</span><br><span class="line">        kernel /vmlinuz-2.6.32-279.el6.x86_64 ro root=UUID=55151a0d-b460-462b-b5c6-97dfd4a3d328 rd_NO_LUKS  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_MD LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet nouveau.modeset=0</span><br><span class="line">        initrd /initramfs-2.6.32-279.el6.x86_64.img</span><br></pre></td></tr></table></figure><p>保存退出后重新启动，再进入文本模式。使用下面的命令来查看一下 nouveau 是否有被加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep nouveau</span><br></pre></td></tr></table></figure><p>如果结果为空，那应该是成功了，可以接下去进行驱动的安装。驱动的安装倒是很简单，我就不打算写一遍了。详细的可以参考<a href="http://www.ideasr.com/forum.php?mod=viewthread&amp;tid=7738&amp;extra=page%3D1&amp;page=1" target="_blank" rel="noopener">这一篇文章</a>。</p><hr><p>更新 Ubuntu 下安装方法：</p><p>在 Ubuntu 下安装驱动的方法步骤还是与在 CentOS 中差不多。</p><p>在引导中加入 <code>nouveau.modeset=0</code> 禁用 nouveau（加不加blacklist关系不大），然后在 CLI 环境下安装驱动。</p><p>Ubuntu 的引导文件位置与 CentOS 并不一样，具体在哪里我也忘了，请自行搜索解决吧。</p><p>禁用 nouveau 后，需要进入 CLI 环境，但是使用 <code>init 3</code> 命令并不能关闭 X Window，会导致安装无法继续进行。</p><p>解决办法是使用 Ctrl+Alt+F1 切换到文字界面下，然后将 dm 服务停止就可以关闭 X Window。Ubuntu 的默认 dm 是 lightdm，其他还有 kdm、gdm 等，请根据自己的情况来选择。</p><p>运行命令 <code>sudo service lightdm stop</code> 来停止X Window。接下来就可以按流程安装驱动了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
