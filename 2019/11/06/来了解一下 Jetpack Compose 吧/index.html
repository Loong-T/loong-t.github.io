<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>来了解一下 Jetpack Compose 吧 • 龙套的博客</title><meta name="description" content="来了解一下 Jetpack Compose 吧 - Loong_T ZHENG"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="https://unpkg.com/nanoreset/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="龙套的博客"><script src="https://www.googletagmanager.com/gtag/js?id=UA-39168233-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'UA-39168233-1');</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="龙套的博客" type="application/atom+xml">
</head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="龙套的博客"><img class="logo-image" src="/logo.svg" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">首页</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/tags" target="_self">标签</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">归档</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="https://github.com/Loong-T" target="_blank">GitHub</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/atom.xml" target="_self">RSS</a></li></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">来了解一下 Jetpack Compose 吧</h1><div class="post-info"><a><p id="post-date">发表时间：2019-11-07</p></a></div><div class="post-content"><p>发表时间：2019.11.7</p>
<p>在前不久的 Android Dev Summit ‘19 上，Jetpack Compose 终于发布了一个可直接获得的预览版。现在的版本还是 0.1.0-dev02，处于非常早期的版本，官方也再三强调非常有可能产生变化且无法用于生产环境。不过我认为这是简单了解一下 Compose 的好时机。有备而无患。</p>
<span id="more"></span>

<p>首先来了解一下现在尝试 Compose 所需要的环境：</p>
<ol>
<li>Android Studio 4.0 Canary1</li>
<li>Kotlin 1.3.60-eap-25</li>
<li>minSdkVersion 21（也就是 Android 5.0）</li>
</ol>
<p>好的，这篇文章就到此为止吧。</p>
<p><img src="https://tva1.sinaimg.cn/large/007X8olVly1g8f4evrq81j3023023jr6.jpg" alt="告辞"></p>
<p>等等！写都写了，我还是再多写一点吧。</p>
<p>演这么一出其实也是为了说明，Compose 真的还处于很早期的阶段，估计还需要很长一段路才能真正在项目中实际使用上。但早鸟多少能尝到些甜头。希望各位能通过简单的了解，预判一下以后的开发趋势，趁早规划，适时投资。</p>
<p>同时由于 Compose 还处于很可能发生很多变化的状态，所以本文也不准备过多拘泥于使用的细节，而是从更为大局的层面上介绍一下 Compose。当然，笔者本人经验和眼界极为有限，真知灼见是没有的，希望起到抛砖引玉的作用。</p>
<h2 id="开始体验"><a href="#开始体验" class="headerlink" title="开始体验"></a>开始体验</h2><p>请记得下载一个<a target="_blank" rel="noopener" href="https://developer.android.com/studio/preview">最新的 Android Studio</a>，需要 4.0 版本，在发文时这意味着你需要使用 canary channel 版本的。</p>
<p>开始新建一个项目，会发现多了一个 Empty Compose Activity 的选项，选择它，各种依赖会为你配置好。那么一个 hello world 会是这个样子的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            MyApp()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Text(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，你已经知道了 Compose 的基础知识，现在可以尝试用它来构建各种界面了。</p>
<p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8f80fbncej301o01amx4.jpg" alt="打脸"></p>
<p>请先慢着动手。如果去看官网的入门教程，你所得到的核心内容的确就是这样。由于文档及教程还很不完善，这里我建议，出门左转学习一下 Flutter。</p>
<p>这不是一句玩笑话。Compose 在控件的使用以及组合上，跟 Flutter 更为相近，而跟 Android 之前的那套 UI 没有太大的关系。使用 Layout Inspector 这个工具来查看 Compose 编写的应用，可以看到 Activity 内是一个 AndroidComposeView 包含了很多 RepaintBoundaryView。而没有使用原先就有的 TextView 等控件。</p>
<p>假如你只接触过 Android 的 UI 编程，可能需要一段时间来熟悉然后转变原先的思维。虽然 Compose 本身还很不完善，但这种声明式的编程范式（declarative programming）可以通过学习 React 或者 Flutter 等 UI 框架未雨绸缪一番。</p>
<p>关于声明式编程稍后再提，我还是继续谈一下一些常见的情形。</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>在布局上，首先会教会你使用 Column 和 Row，能够对应代替 LinearLayout；FrameLayout 也换成了 Stack。如果你对  main axis、cross axis 还比较陌生，如上所说，可以尝试学习一下 React 和 Flutter。</p>
<p>视频中提到，Compose 对 ConstraintLayout 的支持还正在进行中。所以可以猜测还在对于现有的布局控件，以后应该还是会添加支持的。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>大多数应用都逃不了网络请求 + 列表展示！</p>
<p>Compose 提供了 VerticalScroller 和 HorizontalScroller 来生成列表，在使用上与 RecyclerView 是完全不同的体验：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    VerticalScroller &#123;</span><br><span class="line">        Column &#123;</span><br><span class="line">            repeat(<span class="number">20</span>) &#123;</span><br><span class="line">                Row(mainAxisSize = LayoutSize.Expand) &#123;</span><br><span class="line">                    Container(height = <span class="number">48.</span>dp) &#123;</span><br><span class="line">                        Text(<span class="string">&quot;Item <span class="variable">$it</span>&quot;</span>, modifier = Spacing(left = <span class="number">16.</span>dp))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，Scroller 与 ScrollView 更接近，只提供了一个滚动的功能，并没提到有对 View 进行回收复用。</p>
<h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    MaterialTheme &#123;</span><br><span class="line">        Surface(color = Color.White) &#123;</span><br><span class="line">            Text(text = <span class="string">&quot;Hello <span class="variable">$name</span>!&quot;</span>, style = +themeTextStyle &#123; h5 &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码添加了 Material 的主题。</p>
<p>在我看来，这种方式比使用 XML 那套繁琐、不直观、缺乏文档的方法要好太多。当然，也可能只是因为我菜。</p>
<p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8gdget2b3j305d04wq2u.jpg" alt="我太菜"></p>
<h3 id="Live-Preview"><a href="#Live-Preview" class="headerlink" title="Live Preview"></a>Live Preview</h3><p>Android Studio 4.0 还提供了一个名为 Live Preview 的功能来预览 Compose 的效果。通过给 Compose 函数添加 <code>@Preview</code> 注解来预览该函数的效果。这个函数必须是无参的，而且可以给注解传递不同的参数来预览各种不同情况下（不同主题不同屏幕大小等）的界面。</p>
<p>功能是好功能，但代码发生变动后，必须要重新 build 后才能更新预览，现在效率还比较低。</p>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>最后谈谈当状态（数据）发生变化后，Compose 如何响应。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Model</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> state = State()</span><br><span class="line">    MaterialTheme &#123;</span><br><span class="line">        Stack &#123;</span><br><span class="line">            aligned(Alignment.Center) &#123;</span><br><span class="line">                Button(<span class="string">&quot;<span class="subst">$&#123;state.count&#125;</span> clicks&quot;</span>, &#123;</span><br><span class="line">                    state.count++</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，放置了一个按钮，每按一次按钮上的计数就会 +1。代码里并没有对 State 进行监听，然后再对 UI 进行更新。而是在 State 类上添加了 <code>Model</code> 注解，Compose 自动进行 UI 的更新（官方称之为 recompose）。</p>
<p>你或许会想：哦，<code>setState()</code>。</p>
<h2 id="Compose"><a href="#Compose" class="headerlink" title="Compose?"></a>Compose?</h2><h3 id="为什么需要-Compose"><a href="#为什么需要-Compose" class="headerlink" title="为什么需要 Compose"></a>为什么需要 Compose</h3><p>Android 已经十年，设备的变化非常大，也涌现出很多心的开发技术和思想，但用来开发 UI 的工具却还依旧停留在十年前。不少控件已经过时而且背负了太多历史包袱，重新开始或许是更好的选择。</p>
<p>开发 UI 需要编写 XML 布局，通过代码加载，可能还需要通过 XML 来定义 style，为了编写一个界面要做的工作太多了。而且考虑到 Activity 和 Fragment，需要顾及的就更多了。如果要自定义一个 View，要做什么工作？我想“自定义 View”这几个字，都能吓退一批人吧。</p>
<p>并且大量 UI 工具与系统的版本绑定，新功能新修复无法及时让开发者和用户受益。Material design？Who cares？那是 5.0 以上才大部分支持的东西，更别提 shape theming 了。</p>
<p>原先的控件使用了一些只有官方能使用的黑魔法，也就是 hidden API。Compose 将完全在公开的 API 上进行构建，官方使用的广大的普通开发者也能够使用。</p>
<p>插点私货。我偶尔会看着隔壁 Flutter 流下羡慕的泪水。它提供了大量官方的控件，应对各种场景，而且在各种系统版本上提供统一的行为。而我却需要满世界找非官方的实现，一个个查看是否满足我的需求，是否还在维护，是否需要自己魔改。当然，我无比感恩这些开发者的贡献，但我觉得我们应该被 Android 官方善待。</p>
<p>然后是 data flow。对于 UI 编程来说，分发事件和接收状态是与开发者关联最密切的事情。而现有的 android.widget 在这两个方面都做得不够好：状态的管理比较混乱；事件在分发时就已经改变了控件的状态；listener 可以跟 Kotlin 结合更紧密提供更合适的做法。</p>
<h3 id="声明式-UI-编程"><a href="#声明式-UI-编程" class="headerlink" title="声明式 UI 编程"></a>声明式 UI 编程</h3><p>声明式编程通常是相对于命令式编程（imperative programming）来说的，不关注编程中具体的过程，而是以最后的结果为重点。在 UI 这一特定的领域来说，声明式编程则意味着：当状态发生变化时，声明式框架会自动更新视图。</p>
<p>声明式的 UI 框架会关注：</p>
<ol>
<li>对于给定的数据，UI 是如何被展示的；</li>
<li>怎么对事件进行响应；</li>
<li>不考虑 UI 之前的状态对当前的状态产生的影响。</li>
</ol>
<p>也就是说，它只关心当前的数据（状态）会渲染出什么样的外观，而不把数据当成一个拥有上下文的状态流来看待。</p>
<h3 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h3><blockquote>
<p>Composition over inheritance.</p>
<p>组合优于继承。</p>
</blockquote>
<p>Compose 通过组合的方式构成界面。这或许也是起名叫 Compose 的原因。</p>
<p>遵循单一责任原则，Compose 函数都只有一个单一的目的，想实现某一种效果，就使用对应的 Compose 函数。比如想要设置背景，则需要使用 <code>Surface</code>，没有其他 Compose 函数可以做到这一点。</p>
<h2 id="Composable"><a href="#Composable" class="headerlink" title="@Composable"></a>@Composable</h2><p>使用 <code>@Composable</code> 注解的函数只能在另一个的 Composable 函数中调用。看到这句话，你可能会想起：“ 只有替身才能打倒替身 ！”</p>
<p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8ohcynfdxj30f00dm7lb.jpg" alt="你在向我靠近吗"></p>
<p>如果你对 Kotlin Coroutine 有所了解，suspend 函数也同样只能在 suspend 函数中进行调用。而 coroutine 的实现，是 Kotlin 编译器在编译时，将 suspend 函数进行了改造，会给函数添加一个 Continuation 参数，并对函数体进行一定程度的改造。详细的这里不多写了。</p>
<p>对于 Composable 函数，同样也是使用了 Kotlin 编译器插件将函数变形了。Composable 函数里添加的则是 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/kotlin/androidx/compose/Composer">Composer</a>，这是一个类似于 gap buffer 的数据结构。Gap buffer 在文本编辑器里被普遍使用，有兴趣的可以多了解一下。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再次强调，Compose 处于很早期的阶段，API 也好，具体的底层实现也好，都很可能会发生变化。官方的示例 JetNews 也存在一定的性能问题。</p>
<p>所以我觉得普通开发者还不需要去了解具体使用的细节。但还是有几个建议：</p>
<ul>
<li>如果还没学习 Kotlin，快学吧。</li>
<li>然后考虑学习一下 Kotlin coroutine。</li>
<li>学习已经比较成熟的声明式 UI 框架，比如 React 和 Flutter。考虑了解一下它们的应用和原理，比如状态管理的最佳实践和 virtual DOM 等。这样可以快速掌握同类型的 UI 框架。</li>
</ul>
<h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><p><a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose">官网 Compose 页面</a></p>
<p><a target="_blank" rel="noopener" href="https://codelabs.developers.google.com/codelabs/jetpack-compose-basics">Codelab - Jetpack Compose Basics</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/android/compose-samples/tree/master/JetNews">官方示例 JetNews</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=VsStyq4Lzxo">Declarative UI Patterns (Google I/O’19)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=dtm2h-_sNDQ">What’s New in Jetpack Compose (Android Dev Summit ‘19)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Q9MtlmmN4Q0">Understanding Compose (Android Dev Summit ‘19)</a></p>
</div></article></div></main><footer><div class="paginator"><a class="next" href="/2019/10/19/%E4%B8%80%E7%AF%87%E5%85%B3%E4%BA%8E%20Android%20%E8%8E%B7%E5%8F%96%E8%BF%90%E8%90%A5%E5%95%86%E7%9A%84%E5%85%A8%E9%9D%A2%E7%AC%94%E8%AE%B0/">后一篇</a></div><div id="waline"></div><script src="//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js" defer></script><script>document.addEventListener('DOMContentLoaded', (event) => {
    new Waline({
        el: '#waline',
        placeholder: '(ง •_•)ง 欢迎评论',
        path: location.pathname,
        serverURL: 'waline-for-blog.vercel.app'
    });
});</script><div class="copyright"><p>&copy; 2013 - 2021 <a href="https://nerd-is.in/">Loong_T</a><br>Powered by <a href="https://hexo.io/" rel="noreferrer" target="_blank">Hexo</a></p></div></footer></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>